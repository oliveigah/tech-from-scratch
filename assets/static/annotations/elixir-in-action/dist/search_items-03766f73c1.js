searchNodes=[{"doc":"Documentation for 'Calculator'. Contains the documentation for calculator modules used in the book Elixir in Action 2nd Edition","ref":"Chapter2.Calculator.html","title":"Chapter2.Calculator","type":"module"},{"doc":"Divides a number by the otherBook section: 2.4.1This exercise explains that the '/' operator always returns a floatExamplesiex&gt; Chapter2.Calculator.division(1,1) 1.0 iex&gt; Chapter2.Calculator.division(1,4) 0.25","ref":"Chapter2.Calculator.html#division/2","title":"Chapter2.Calculator.division/2","type":"function"},{"doc":"Gets the integer part of a divisionBook section: 2.4.1This exercise explains how to use the kernel function divExamplesiex&gt; Chapter2.Calculator.integer_of_div(1,1) 1 iex&gt; Chapter2.Calculator.integer_of_div(5,2) 2","ref":"Chapter2.Calculator.html#integer_of_div/2","title":"Chapter2.Calculator.integer_of_div/2","type":"function"},{"doc":"Gets the remainder part of a divisionBook section: 2.4.1This exercise explains how to use the kernel function remExamplesiex&gt; Chapter2.Calculator.remainder_of_div(1,1) 0 iex&gt; Chapter2.Calculator.remainder_of_div(1,4) 1","ref":"Chapter2.Calculator.html#remainder_of_div/2","title":"Chapter2.Calculator.remainder_of_div/2","type":"function"},{"doc":"Sum two numbersBook section: 2.3.3This exercise explains the usual pattern that low arity delegates to higher arity functions with some default argument valuesExamplesiex&gt; Chapter2.Calculator.sum(1) 1 iex&gt; Chapter2.Calculator.sum(1,4) 5","ref":"Chapter2.Calculator.html#sum/2","title":"Chapter2.Calculator.sum/2","type":"function"},{"doc":"Documentation for Generic.Contains the documentation for generic modules used in the book Elixir in Action 2nd Edition.","ref":"Chapter2.Generic.html","title":"Chapter2.Generic","type":"module"},{"doc":"Hello world.Examplesiex&gt; Chapter2.Generic.hello() :world","ref":"Chapter2.Generic.html#hello/0","title":"Chapter2.Generic.hello/0","type":"function"},{"doc":"Documentation for 'Geometry'. Contains the documentation for geometries modules used in the book Elixir in Action 2nd Edition","ref":"Chapter2.Geometry.html","title":"Chapter2.Geometry","type":"module"},{"doc":"Calculate the area of a circleBook section: 2.3.6This exercise explains the usage of module attributes and how to combine functions in docTests. In this case I'm using @pi as a module attributeExamplesiex&gt; Chapter2.Geometry.circle_area(3) |&gt; Float.round(2) 28.27","ref":"Chapter2.Geometry.html#circle_area/1","title":"Chapter2.Geometry.circle_area/1","type":"function"},{"doc":"Calculate the circunference of a circleBook section: 2.3.6This exercise explains the usage of module attributes and how to combine functions in docTests. In this case I'm using @pi as a module attributeExamplesiex&gt; Chapter2.Geometry.circle_circunference(3) |&gt; Float.round(2) 18.85","ref":"Chapter2.Geometry.html#circle_circunference/1","title":"Chapter2.Geometry.circle_circunference/1","type":"function"},{"doc":"Calculate the area of a rectangleBook section: 2.3.1This exercise explains the creation and use of a functionExamplesiex&gt; Chapter2.Geometry.rectangle_area(3,2) 6 iex&gt; Chapter2.Geometry.rectangle_area(1,7) 7","ref":"Chapter2.Geometry.html#rectangle_area/2","title":"Chapter2.Geometry.rectangle_area/2","type":"function"},{"doc":"Calculate the area of a squareBook section: 2.3.3This exercise explains the usual pattern that low arity delegates to higher arity functions with some default argument valuesIn this case, a square is a subset of rectangles so the area function can be implemented as a rectangle area call with both parameters having equal valuesExamplesiex&gt; Chapter2.Geometry.square_area(3) 9 iex&gt; Chapter2.Geometry.square_area(7) 49","ref":"Chapter2.Geometry.html#square_area/1","title":"Chapter2.Geometry.square_area/1","type":"function"},{"doc":"This module explain how guards work on multi-clauses functions. Book section: 3.2","ref":"Chapter3.CheckNumber.html","title":"Chapter3.CheckNumber","type":"module"},{"doc":"Indicates if a number is positive, negative or zero.Book section: 3.2.2This exercises shows how to use guards on multi-clauses functions to achieve &quot;if like&quot; behavioursExamplesiex&gt; Chapter3.CheckNumber.check(2) :positive iex&gt; Chapter3.CheckNumber.check(0) :zero iex&gt; Chapter3.CheckNumber.check(-1) :negative","ref":"Chapter3.CheckNumber.html#check/1","title":"Chapter3.CheckNumber.check/1","type":"function"},{"doc":"Indicates if a number is positive, negative or zero.Book section: 3.3.2This exercises shows how to use branching with cond macroExamplesiex&gt; Chapter3.CheckNumber.cond_check(2) :positive iex&gt; Chapter3.CheckNumber.cond_check(0) :zero iex&gt; Chapter3.CheckNumber.cond_check(-1) :negative","ref":"Chapter3.CheckNumber.html#cond_check/1","title":"Chapter3.CheckNumber.cond_check/1","type":"function"},{"doc":"This module explain how to use high-order functions (Enum and Stream) to iterate over enumerables Book section: 3.4","ref":"Chapter3.FileHelper.html","title":"Chapter3.FileHelper","type":"module"},{"doc":"Get just the lines above 80 characters from a fileBook section: 3.4.5Examplesiex&gt; Chapter3.FileHelper.large_lines!(&quot;./test/chapters/.resources/text_file.txt&quot;) [&quot;this is a very very very very very very very very very very very very very long line&quot;]","ref":"Chapter3.FileHelper.html#large_lines!/1","title":"Chapter3.FileHelper.large_lines!/1","type":"function"},{"doc":"Get the lines length of a fileBook section: 3.4.5Examplesiex&gt; Chapter3.FileHelper.lines_lengths!(&quot;./test/chapters/.resources/text_file.txt&quot;) [1,3,5,7,9,84,35,23]","ref":"Chapter3.FileHelper.html#lines_lengths!/1","title":"Chapter3.FileHelper.lines_lengths!/1","type":"function"},{"doc":"Get the longest line of a fileBook section: 3.4.5Examplesiex&gt; Chapter3.FileHelper.longest_line!(&quot;./test/chapters/.resources/text_file.txt&quot;) &quot;this is a very very very very very very very very very very very very very long line&quot;","ref":"Chapter3.FileHelper.html#longest_line!/1","title":"Chapter3.FileHelper.longest_line!/1","type":"function"},{"doc":"Get the longest line length of a fileBook section: 3.4.5Examplesiex&gt; Chapter3.FileHelper.longest_line_length!(&quot;./test/chapters/.resources/text_file.txt&quot;) 84","ref":"Chapter3.FileHelper.html#longest_line_length!/1","title":"Chapter3.FileHelper.longest_line_length!/1","type":"function"},{"doc":"Get the the number of words per line of a fileBook section: 3.4.5Examplesiex&gt; Chapter3.FileHelper.words_per_line!(&quot;./test/chapters/.resources/text_file.txt&quot;) [1,2,3,4,5,18,18,12]","ref":"Chapter3.FileHelper.html#words_per_line!/1","title":"Chapter3.FileHelper.words_per_line!/1","type":"function"},{"doc":"This module explain how multi-clauses functions works. Book section: 3.2","ref":"Chapter3.Geometry.html","title":"Chapter3.Geometry","type":"module"},{"doc":"Calculate the area of a geometric shape.Book section: 3.2.1This exercises shows how to build multi-clauses functions, in this case the function area has 3 distincts implementations depends on clause that is successful matchs at runtime.The pinpoint of this is the pattern matching explained on this section.Examplesiex&gt; Chapter3.Geometry.area({:rectangle, 3, 7}) 21 iex&gt; Chapter3.Geometry.area({:square, 3}) 9 iex&gt; Chapter3.Geometry.area({:circle, 3}) |&gt; Float.round(2) 28.27","ref":"Chapter3.Geometry.html#area/1","title":"Chapter3.Geometry.area/1","type":"function"},{"doc":"This module explains how pattern macthing and multiclause functions are powerfull tools to build recursive functions and how use tail and non-tail recursions to build iterations Book section: 3.3 and 3.4","ref":"Chapter3.ListHelper.html","title":"Chapter3.ListHelper","type":"module"},{"doc":"Get the length of a list using non tail recursive function callBook section: 3.4.1This exercises shows how to built iterations using recursive functionsAnd shows how to use the list notation of [head | tails]Examplesiex&gt; Chapter3.ListHelper.no_tail_len([2,3,5,10]) 4 iex&gt; Chapter3.ListHelper.no_tail_len([0,0,33,2,7]) 5 iex&gt; Chapter3.ListHelper.no_tail_len([]) 0","ref":"Chapter3.ListHelper.html#no_tail_len/1","title":"Chapter3.ListHelper.no_tail_len/1","type":"function"},{"doc":"Get a list with just the positives integer on a list using non tail recursive callBook section: 3.4.2This exercises shows how to build iterations using non tail recursive functionsExamplesiex&gt; Chapter3.ListHelper.non_tail_positives([0,5,7,-3,8,-2,-1]) [5,7,8] iex&gt; Chapter3.ListHelper.non_tail_positives([3,2,1]) [3,2,1] iex&gt; Chapter3.ListHelper.non_tail_positives([-7,-10]) []","ref":"Chapter3.ListHelper.html#non_tail_positives/1","title":"Chapter3.ListHelper.non_tail_positives/1","type":"function"},{"doc":"Get a list of integers between 2 numbers using non tail recursive callBook section: 3.4.2This exercises shows how to build iterations using non tail recursive functionsExamplesiex&gt; Chapter3.ListHelper.non_tail_range(0,5) [0,1,2,3,4,5] iex&gt; Chapter3.ListHelper.non_tail_range(7,7) [7] iex&gt; Chapter3.ListHelper.non_tail_range(7,10) [7,8,9,10]","ref":"Chapter3.ListHelper.html#non_tail_range/2","title":"Chapter3.ListHelper.non_tail_range/2","type":"function"},{"doc":"Sum all elements on a listBook section: 3.3.1 | 3.4.1This exercises shows how to use multiclause functions to build recursive functions more easilyAnd shows how to use the list notation of [head | tails]Examplesiex&gt; Chapter3.ListHelper.sum([2,3,5,10]) 20 iex&gt; Chapter3.ListHelper.sum([0,0,33,2,7]) 42 iex&gt; Chapter3.ListHelper.sum([]) 0","ref":"Chapter3.ListHelper.html#sum/1","title":"Chapter3.ListHelper.sum/1","type":"function"},{"doc":"Get the length of a list using tail recursive function callBook section: 3.4.2This exercises shows how to build iterations using tail recursive functionsAnd shows how to use the list notation of [head | tails]Examplesiex&gt; Chapter3.ListHelper.tail_len([2,3,5,10]) 4 iex&gt; Chapter3.ListHelper.tail_len([0,0,33,2,7]) 5 iex&gt; Chapter3.ListHelper.tail_len([]) 0","ref":"Chapter3.ListHelper.html#tail_len/1","title":"Chapter3.ListHelper.tail_len/1","type":"function"},{"doc":"Get a list with just the positives integer on a list using tail recursive callBook section: 3.4.2This exercises shows how to build iterations using tail recursive functionsExamplesiex&gt; Chapter3.ListHelper.tail_positives([0,5,7,-3,8,-2,-1]) [5,7,8] iex&gt; Chapter3.ListHelper.tail_positives([3,2,1]) [3,2,1] iex&gt; Chapter3.ListHelper.tail_positives([-7,-10]) []","ref":"Chapter3.ListHelper.html#tail_positives/1","title":"Chapter3.ListHelper.tail_positives/1","type":"function"},{"doc":"Get a list of integers between 2 numbers using tail recursive callBook section: 3.4.2This exercises shows how to build iterations using tail recursive functionsThe logic was made inverse because of performance, since lists are O(1) to insert on the start and O(n) to insert on the end its better to build the list from end to startExamplesiex&gt; Chapter3.ListHelper.tail_range(0,5) [0,1,2,3,4,5] iex&gt; Chapter3.ListHelper.tail_range(7,7) [7] iex&gt; Chapter3.ListHelper.tail_range(7,10) [7,8,9,10]","ref":"Chapter3.ListHelper.html#tail_range/2","title":"Chapter3.ListHelper.tail_range/2","type":"function"},{"doc":"This module explain how to use the with special form Book section: 3.3","ref":"Chapter3.MapHelper.html","title":"Chapter3.MapHelper","type":"module"},{"doc":"Normalize a map to a map containing :login, :email and :password keysBook section: 3.3.3This exercises shows how to use with macro and pattern matching to achieve more elegant code.Without with a chain of case or if would be necessary.Examplesiex&gt; Chapter3.MapHelper.normalize_user!(%{&quot;wrong&quot; =&gt; &quot;data&quot;}) {:error, &quot;login missing&quot;} iex&gt; Chapter3.MapHelper.normalize_user!(%{&quot;login&quot; =&gt; &quot;example&quot;}) {:error, &quot;email missing&quot;} iex&gt; Chapter3.MapHelper.normalize_user!(%{&quot;login&quot; =&gt; &quot;example&quot;, &quot;email&quot; =&gt; &quot;example@email.com&quot;}) {:error, &quot;password missing&quot;} iex&gt; Chapter3.MapHelper.normalize_user!(%{&quot;login&quot; =&gt; &quot;example&quot;, &quot;email&quot; =&gt; &quot;example@email.com&quot;, &quot;password&quot; =&gt; &quot;secret&quot;, &quot;other&quot; =&gt; &quot;data&quot;}) {:ok, %{login: &quot;example&quot;, email: &quot;example@email.com&quot;, password: &quot;secret&quot;}}","ref":"Chapter3.MapHelper.html#normalize_user!/1","title":"Chapter3.MapHelper.normalize_user!/1","type":"function"},{"doc":"This module explains how to build higher level data structures with built-in types and how to use struct and apply pattern matching with it Book Section 4.1","ref":"Chapter4.Fraction.html","title":"Chapter4.Fraction","type":"module"},{"doc":"Add two fractions and return the resultBook section: 4.1.4This function shows how to use pattern matching with structsExamplesiex&gt; Chapter4.Fraction.add(Chapter4.Fraction.new(1,2), Chapter4.Fraction.new(1,4)) %Chapter4.Fraction{numerator: 6, denominator: 8} iex&gt; Chapter4.Fraction.add(Chapter4.Fraction.new(3,2), Chapter4.Fraction.new(1,4)) %Chapter4.Fraction{numerator: 14, denominator: 8}","ref":"Chapter4.Fraction.html#add/2","title":"Chapter4.Fraction.add/2","type":"function"},{"doc":"Create a new fraction data abstractionBook section: 4.1.4This function shows how to build constructors-like behaviour on elixirExamplesiex&gt; Chapter4.Fraction.new(1,2) %Chapter4.Fraction{numerator: 1, denominator: 2} iex&gt; Chapter4.Fraction.new(5,3) %Chapter4.Fraction{numerator: 5, denominator: 3}","ref":"Chapter4.Fraction.html#new/2","title":"Chapter4.Fraction.new/2","type":"function"},{"doc":"Get the float equivalent value of a fractionBook section: 4.1.4This function shows how to use pattern matching with structsExamplesiex&gt; Chapter4.Fraction.new(1,2) |&gt; Chapter4.Fraction.value() 0.5 iex&gt; Chapter4.Fraction.value(%Chapter4.Fraction{numerator: 3, denominator: 4}) 0.75","ref":"Chapter4.Fraction.html#value/1","title":"Chapter4.Fraction.value/1","type":"function"},{"doc":"In this example, the struct fraction is built with the built-in type map. Because of the usage of struct it is slight different of a conventional map, but most functions from the Map module will work with it","ref":"Chapter4.Fraction.html#t:fraction/0","title":"Chapter4.Fraction.fraction/0","type":"type"},{"doc":"This module explains how to build a server process with mutable state and how to interact with itServer process contains 2 types of functions, interfaces and implementationsThis module is a calculator server that runs the aritmetic operations in a non blocking manner to the client processThe current result of the calculation is stored as the process state, and it is mutate by client calls with operations such as add/2 and sub/2 Book section: 5.3","ref":"Chapter5.Calculator.html","title":"Chapter5.Calculator","type":"module"},{"doc":"Add a value on the current stateThis an interface function, this means that this code runs on the client process sideOn this case the caller does not request a repsonse from the server,so no message is sendBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; Chapter5.Calculator.add(server_pid, 5) iex&gt; Chapter5.Calculator.get_result(server_pid) 5","ref":"Chapter5.Calculator.html#add/2","title":"Chapter5.Calculator.add/2","type":"function"},{"doc":"Divides the current state by a valueThis an interface function, this means that this code runs on the client process sideOn this case the caller does not request a repsonse from the server,so no message is sendBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; Chapter5.Calculator.add(server_pid, 5) iex&gt; Chapter5.Calculator.div(server_pid, 2) iex&gt; Chapter5.Calculator.get_result(server_pid) 2.5","ref":"Chapter5.Calculator.html#div/2","title":"Chapter5.Calculator.div/2","type":"function"},{"doc":"Get the current calculation result on the server stateThis an interface function, this means that this code runs on the client process sideInterface functions abstract the implementation details to use a server process, in this example the client do not have to know that a message to get the current stat must match {:val, pid}The self() call here is evaluated with the client pid, because this is an interface functionBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; Chapter5.Calculator.get_result(server_pid) 0","ref":"Chapter5.Calculator.html#get_result/1","title":"Chapter5.Calculator.get_result/1","type":"function"},{"doc":"This is the tail recursion used to keep the server process runingThis an implementation function, this means that this code runs on the server process sidePattern matching is used to filter the incoming messagesA commom pattern is to separate all the patter matching stuff on a separate function, to avoid a huge switch like constructThen a message is sent to the caller with the result of the computation doneImplementation functions usually are private but for documentation purpose they are pulic hereThe new state is passed as parameter to the next loop iterationBook section: 5.3.1 e 5.3.2Examplesiex&gt; server_pid = Chapter5.DatabaseServer.start() iex&gt; is_pid(server_pid) true","ref":"Chapter5.Calculator.html#loop/1","title":"Chapter5.Calculator.loop/1","type":"function"},{"doc":"Multiply the current state by a valueThis an interface function, this means that this code runs on the client process sideOn this case the caller does not request a repsonse from the server,so no message is sendBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; Chapter5.Calculator.add(server_pid, 5) iex&gt; Chapter5.Calculator.mul(server_pid, 3) iex&gt; Chapter5.Calculator.get_result(server_pid) 15","ref":"Chapter5.Calculator.html#mul/2","title":"Chapter5.Calculator.mul/2","type":"function"},{"doc":"Start a new calculator server processThis an interface function, this means that this code runs on the client process sideTo keep the process runing a tail recursion is neededThe initial state is initialized here and passes to the loop functionBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; is_pid(server_pid) true","ref":"Chapter5.Calculator.html#start/0","title":"Chapter5.Calculator.start/0","type":"function"},{"doc":"Subtract a value on the current stateThis an interface function, this means that this code runs on the client process sideOn this case the caller does not request a repsonse from the server,so no message is sendBook section: 5.3.3Examplesiex&gt; server_pid = Chapter5.Calculator.start() iex&gt; Chapter5.Calculator.sub(server_pid, 5) iex&gt; Chapter5.Calculator.get_result(server_pid) -5","ref":"Chapter5.Calculator.html#sub/2","title":"Chapter5.Calculator.sub/2","type":"function"},{"doc":"This module explains how to build a server process with immutable state and how to interact with itServer process contains 2 types of functions, interfaces and implementationsThis moule emulate a database server that handle queries executions through a connection established on the process start Book section: 5.3","ref":"Chapter5.DatabaseServer.html","title":"Chapter5.DatabaseServer","type":"module"},{"doc":"Get the oldest query result that was executed by a Chapter5.DatabaseServer server processThis an interface function, this means that this code runs on the client process sideThe self() call here is evaluated with the client pid, because this is an interface functionInterface functions abstract the implementation details to use a server process, like here the client do not have to know that messages from the server process are sent matching this pattern {:query_result, result}Book section: 5.3.1 e 5.3.2Examplesiex&gt; server_pid = Chapter5.DatabaseServer.start() iex&gt; Chapter5.DatabaseServer.run_async(server_pid, &quot;query 1&quot;) iex&gt; result = Chapter5.DatabaseServer.get_result() iex&gt; compare_result = String.split(result,&quot;:&quot;) iex&gt; List.last(compare_result) &quot;query 1 result&quot;","ref":"Chapter5.DatabaseServer.html#get_result/0","title":"Chapter5.DatabaseServer.get_result/0","type":"function"},{"doc":"This is the tail recursion used to keep the server process runingThis an implementation function, this means that this code runs on the server process sidePattern matching is used to filter the incoming messagesThen a message is sent to the caller with the result of the computation doneImplementation functions usually are private but for documentation purpose they are pulic hereThe initial state is passed as parameter to the next loop iterationBook section: 5.3.1 e 5.3.2Examplesiex&gt; server_pid = Chapter5.DatabaseServer.start() iex&gt; is_pid(server_pid) true","ref":"Chapter5.DatabaseServer.html#loop/1","title":"Chapter5.DatabaseServer.loop/1","type":"function"},{"doc":"Run a query on a specific database server processThis an interface function, this means that this code runs on the client process sideThe self() call here is evaluated with the client pid, because this is an interface functionInterface functions abstract the implementation details to use a server process, like here the client do not have to know that to run a query it must send a message taht matchs with it {:run_query, self(), query_def}Although the client may know the internal representation of the method, it should not rely on it Book section: 5.3.1 e 5.3.2Examplesiex&gt; server_pid = Chapter5.DatabaseServer.start() iex&gt; client_pid = self() iex&gt; result = Chapter5.DatabaseServer.run_async(server_pid, &quot;query 1&quot;) iex&gt; {:run_query, ^client_pid, &quot;query 1&quot;} = result","ref":"Chapter5.DatabaseServer.html#run_async/2","title":"Chapter5.DatabaseServer.run_async/2","type":"function"},{"doc":"Start a new server process to execute a queriesThis an interface function, this means that this code runs on the client process sideTo keep the process runing a tail recursion is neededThe initial state is initialized here and passes to the loop functionBook section: 5.3.1 e 5.3.2Examplesiex&gt; server_pid = Chapter5.DatabaseServer.start() iex&gt; is_pid(server_pid) true","ref":"Chapter5.DatabaseServer.html#start/0","title":"Chapter5.DatabaseServer.start/0","type":"function"},{"doc":"This module explains how to spawn a new process and receive messages from it Book section: 5.2","ref":"Chapter5.QueryHelper.html","title":"Chapter5.QueryHelper","type":"module"},{"doc":"Simulate a database call with 2 seconds delayBook section: 5.2.1","ref":"Chapter5.QueryHelper.html#execute_query/1","title":"Chapter5.QueryHelper.execute_query/1","type":"function"},{"doc":"Spawn a new process to executes a queryself/1 is used to get the caller pid wich will be send to the new processself/1 can should not be called inside the spawn/1 functionA deep copy of every data passed to spawn/1 is send to the new processBook section: 5.2.1","ref":"Chapter5.QueryHelper.html#execute_query_on_another_process/1","title":"Chapter5.QueryHelper.execute_query_on_another_process/1","type":"function"},{"doc":"Get the first query result from the process inboxThis function relies on patten matching to distinguish between query result messages and other possible messages on the inboxTo prevent being stuck if no message has arrived, the clause after is used. Kind of a timeoutBook section: 5.2.2","ref":"Chapter5.QueryHelper.html#get_some_result_from_inbox/0","title":"Chapter5.QueryHelper.get_some_result_from_inbox/0","type":"function"},{"doc":"Run a list of queries asynchronouslyThis function always takes 2 seconds to executeAlthough, it does not return the queries results, it returns a list of pidsBook section: 5.2.2","ref":"Chapter5.QueryHelper.html#run_queries_async/1","title":"Chapter5.QueryHelper.run_queries_async/1","type":"function"},{"doc":"Run a list of queries synchronouslyThis function takes 2 * length(list) seconds to executeBook section: 5.2.1","ref":"Chapter5.QueryHelper.html#run_queries_sync/1","title":"Chapter5.QueryHelper.run_queries_sync/1","type":"function"},{"doc":"This module explains how to build a module that relies on GenServerThe basic approach is similiar to the Chapter6.MyKeyValueStoreThis callback module must implement a set of functions in order to be compatible with GenServer Book section: 6.2","ref":"Chapter6.KeyValueStore.html","title":"Chapter6.KeyValueStore","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Chapter6.KeyValueStore.html#child_spec/1","title":"Chapter6.KeyValueStore.child_spec/1","type":"function"},{"doc":"Get the value referenced by a specific key synchronouslyIf a function should be running synchronously, it must use the GenServer.call/2 functionBook section: 6.2.3Examplesiex&gt; {:ok, pid} = Chapter6.KeyValueStore.start() iex&gt; Chapter6.KeyValueStore.put(pid, :first, &quot;value&quot;) iex&gt; Chapter6.KeyValueStore.get(pid, :first) &quot;value&quot; iex&gt; {:ok, pid} = Chapter6.KeyValueStore.start() iex&gt; Chapter6.KeyValueStore.get(pid, :first) nil","ref":"Chapter6.KeyValueStore.html#get/2","title":"Chapter6.KeyValueStore.get/2","type":"function"},{"doc":"Handle generic custom calls to the serverAny message that arrives to the server that do not fall into one of the 2 categories, cast or call will be handled by this functionBook section: 6.2.4","ref":"Chapter6.KeyValueStore.html#handle_info/2","title":"Chapter6.KeyValueStore.handle_info/2","type":"function"},{"doc":"Initialize the serverThe function :timer.send_interval is used to send a periodically request to the serverBook section: 6.2.4","ref":"Chapter6.KeyValueStore.html#init/1","title":"Chapter6.KeyValueStore.init/1","type":"function"},{"doc":"Add a key/value pair asynchronouslyIf a function should be running asynchronously, it must use the GenServer.cast/2 functionBook section: 6.2.3Examplesiex&gt; {:ok, pid} = Chapter6.KeyValueStore.start() iex&gt; Chapter6.KeyValueStore.put(pid, :first, &quot;value&quot;) iex&gt; Chapter6.KeyValueStore.get(pid, :first) &quot;value&quot;","ref":"Chapter6.KeyValueStore.html#put/3","title":"Chapter6.KeyValueStore.put/3","type":"function"},{"doc":"Starts the server processThis function relies in GenServer.start/3Book section: 6.2.2Examplesiex&gt; {:ok, pid} = Chapter6.KeyValueStore.start() iex&gt; is_pid(pid) true","ref":"Chapter6.KeyValueStore.html#start/0","title":"Chapter6.KeyValueStore.start/0","type":"function"},{"doc":"This module explains how to build a concrete module that relies on a generic server implementationThe concrete module relies on functions such as Chapter6.MyServerProcess.start/1, Chapter6.MyServerProcess.cast/2 and Chapter6.MyServerProcess.call/2 to implement a server process with no boilerplateThe clarity of the code using a GenServer abstraction is way higher Book section: 6.1","ref":"Chapter6.MyKeyValueStore.html","title":"Chapter6.MyKeyValueStore","type":"module"},{"doc":"Get the value referenced by a specific key synchronouslyIf a function should be running synchronously, it must use the Chapter6.MyServerProcess.call/2 functionBook section: 6.1.3Examplesiex&gt; pid = Chapter6.MyKeyValueStore.start() iex&gt; Chapter6.MyKeyValueStore.put(pid, :first, &quot;value&quot;) iex&gt; Chapter6.MyKeyValueStore.get(pid, :first) &quot;value&quot;","ref":"Chapter6.MyKeyValueStore.html#get/2","title":"Chapter6.MyKeyValueStore.get/2","type":"function"},{"doc":"Handle a sync get messageThe return of the handle_cast functions implementations should always be in the same format that the abstraction expects {result, new_state}Book section: 6.1.3Examplesiex&gt; Chapter6.MyKeyValueStore.handle_call({:get, :key} , %{key: &quot;value&quot;}) {&quot;value&quot;, %{key: &quot;value&quot;}} iex&gt; Chapter6.MyKeyValueStore.handle_call({:get, :key} , %{}) {nil, %{}}","ref":"Chapter6.MyKeyValueStore.html#handle_call/2","title":"Chapter6.MyKeyValueStore.handle_call/2","type":"function"},{"doc":"Handle an async put messageThe return of the handle_cast functions implementations should always be the new state valueBook section: 6.1.4Examplesiex&gt; Chapter6.MyKeyValueStore.handle_cast({:put, :key, &quot;value&quot;}, %{}) %{key: &quot;value&quot;} iex&gt; Chapter6.MyKeyValueStore.handle_cast({:put, :key, &quot;value&quot;}, %{other_key: &quot;other_value&quot;}) %{key: &quot;value&quot;, other_key: &quot;other_value&quot;}","ref":"Chapter6.MyKeyValueStore.html#handle_cast/2","title":"Chapter6.MyKeyValueStore.handle_cast/2","type":"function"},{"doc":"Return the initial state of the serverThis function is used inside the Chapter6.MyServerProcess.start/1 implementation to set the initial state of the server processBook section: 6.1.3Examplesiex&gt; Chapter6.MyKeyValueStore.init() %{}","ref":"Chapter6.MyKeyValueStore.html#init/0","title":"Chapter6.MyKeyValueStore.init/0","type":"function"},{"doc":"Add a key/value pair asynchronouslyIf a function should be running asynchronously, it must use the Chapter6.MyServerProcess.cast/2 functionBook section: 6.1.3Examplesiex&gt; pid = Chapter6.MyKeyValueStore.start() iex&gt; Chapter6.MyKeyValueStore.put(pid, :first, &quot;value&quot;) iex&gt; Chapter6.MyKeyValueStore.get(pid, :first) &quot;value&quot;","ref":"Chapter6.MyKeyValueStore.html#put/3","title":"Chapter6.MyKeyValueStore.put/3","type":"function"},{"doc":"Starts the server processThis function relies in Chapter6.MyServerProcess.start/1Book section: 6.1.3Examplesiex&gt; pid = Chapter6.MyKeyValueStore.start() iex&gt; is_pid(pid) true","ref":"Chapter6.MyKeyValueStore.html#start/0","title":"Chapter6.MyKeyValueStore.start/0","type":"function"},{"doc":"This module explains how to build a generic server process that abstracts implementation details to build a server processA concrete module will be provided by dependency injection to fill the specific implementation but all the flow of control will be managed by this processThis helps the concrete modules to be focused on the implementation details of what is relevant for it, making it more clean and easy to understandTo this method work, the concrete module has to implement a well defined set of functions very similar to a interface in OO Book section: 6.1","ref":"Chapter6.MyServerProcess.html","title":"Chapter6.MyServerProcess","type":"module"},{"doc":"Make a call to the server process and await for it responseThis function will handle all the requests to the concrete server that the client want to know the resultThe concrete function must call this function always that a interface function should run synchronously. eg.this functionBook section: 6.1.2Examples iex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyStackServer.put(pid, &quot;first&quot;) iex&gt; Chapter6.MyServerProcess.call(pid, {:get}) &quot;first&quot; iex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyServerProcess.call(pid, {:get}) :stack_is_empty","ref":"Chapter6.MyServerProcess.html#call/2","title":"Chapter6.MyServerProcess.call/2","type":"function"},{"doc":"Make a call to the server process and do not wait for it responseThis function will handle all the requests to the concrete server that the client do not want to know the resultThe concrete function must call this function always that a interface function should run asynchronously. eg.this functionBook section: 6.1.4Examples iex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyServerProcess.cast(pid, {:put, &quot;first&quot;}) {:cast, {:put, &quot;first&quot;}}","ref":"Chapter6.MyServerProcess.html#cast/2","title":"Chapter6.MyServerProcess.cast/2","type":"function"},{"doc":"Starts the injected module as a server processThe injected module must implement init/0 function, that return the initial state of the server processThe injected module is passed as parameter to the loop/2 functionBook section: 6.1.1Examplesiex&gt; pid = Chapter6.MyServerProcess.start(Chapter6.MyStackServer) iex&gt; is_pid(pid) true","ref":"Chapter6.MyServerProcess.html#start/1","title":"Chapter6.MyServerProcess.start/1","type":"function"},{"doc":"This is a concrete test module built to test the Chapter6.MyServerProcess generic module","ref":"Chapter6.MyStackServer.html","title":"Chapter6.MyStackServer","type":"module"},{"doc":"Synchronously retrieve the first element of the stackExamplesiex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyStackServer.get(pid) :stack_is_empty iex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyStackServer.put(pid, &quot;first&quot;) iex&gt; Chapter6.MyStackServer.put(pid, &quot;second&quot;) iex&gt; Chapter6.MyStackServer.get(pid) &quot;second&quot;","ref":"Chapter6.MyStackServer.html#get/1","title":"Chapter6.MyStackServer.get/1","type":"function"},{"doc":"Handle a sync get messageExamplesiex&gt; Chapter6.MyStackServer.handle_call({:get}, []) {:stack_is_empty, []}","ref":"Chapter6.MyStackServer.html#handle_call/2","title":"Chapter6.MyStackServer.handle_call/2","type":"function"},{"doc":"Handle an async put messageExamplesiex&gt; Chapter6.MyStackServer.handle_cast({:put,&quot;value&quot;}, []) [&quot;value&quot;] iex&gt; Chapter6.MyStackServer.handle_cast({:put,&quot;value 3&quot;}, [&quot;value 2&quot; | [&quot;value 1&quot;]]) [&quot;value 3&quot; | [&quot;value 2&quot;, &quot;value 1&quot;]]","ref":"Chapter6.MyStackServer.html#handle_cast/2","title":"Chapter6.MyStackServer.handle_cast/2","type":"function"},{"doc":"Asynchronously add a value to the stackExamplesiex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyStackServer.put(pid, &quot;first&quot;) iex&gt; Chapter6.MyStackServer.get(pid) &quot;first&quot; iex&gt; pid = Chapter6.MyStackServer.start() iex&gt; Chapter6.MyStackServer.put(pid, &quot;first&quot;) iex&gt; Chapter6.MyStackServer.put(pid, &quot;second&quot;) iex&gt; Chapter6.MyStackServer.get(pid) &quot;second&quot;","ref":"Chapter6.MyStackServer.html#put/2","title":"Chapter6.MyStackServer.put/2","type":"function"},{"doc":"This module explains how to use via tuples patten to create named servers dynamically using the Registry moduleBecause this method relies on Registry the server is empowered by the benefits of the Registry module such as the capability of register and lookup for dynamically generated processes id's Book section: 9.1","ref":"Chapter9.EchoServer.html","title":"Chapter9.EchoServer","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Chapter9.EchoServer.html#child_spec/1","title":"Chapter9.EchoServer.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Chapter9.EchoServer.html#init/1","title":"Chapter9.EchoServer.init/1","type":"function"},{"doc":"","ref":"Chapter9.EchoServer.html#send/2","title":"Chapter9.EchoServer.send/2","type":"function"},{"doc":"","ref":"Chapter9.EchoServer.html#start_link/1","title":"Chapter9.EchoServer.start_link/1","type":"function"},{"doc":"The via_tuple function is used to retrieve a process identifier on the Registry server using just the Chapter9.EchoServer server process identifier","ref":"Chapter9.EchoServer.html#via_tuple/1","title":"Chapter9.EchoServer.via_tuple/1","type":"function"},{"doc":"","ref":"Chapter10.Bench.html","title":"Chapter10.Bench","type":"module"},{"doc":"","ref":"Chapter10.Bench.html#run/2","title":"Chapter10.Bench.run/2","type":"function"},{"doc":"This module explains how to use ETS table as a key/value storeDiferent from the usual key value store implemented with a map, where puts and gets are calls handled by the server, on ETS puts and gets are executed on the client side Book section: 10.3","ref":"Chapter10.EtsKeyValue.html","title":"Chapter10.EtsKeyValue","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Chapter10.EtsKeyValue.html#child_spec/1","title":"Chapter10.EtsKeyValue.child_spec/1","type":"function"},{"doc":"","ref":"Chapter10.EtsKeyValue.html#get/1","title":"Chapter10.EtsKeyValue.get/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Chapter10.EtsKeyValue.html#init/1","title":"Chapter10.EtsKeyValue.init/1","type":"function"},{"doc":"","ref":"Chapter10.EtsKeyValue.html#put/2","title":"Chapter10.EtsKeyValue.put/2","type":"function"},{"doc":"","ref":"Chapter10.EtsKeyValue.html#start_link/0","title":"Chapter10.EtsKeyValue.start_link/0","type":"function"},{"doc":"","ref":"Chapter10.KeyValueStore.html","title":"Chapter10.KeyValueStore","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Chapter10.KeyValueStore.html#child_spec/1","title":"Chapter10.KeyValueStore.child_spec/1","type":"function"},{"doc":"","ref":"Chapter10.KeyValueStore.html#get/1","title":"Chapter10.KeyValueStore.get/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Chapter10.KeyValueStore.html#init/1","title":"Chapter10.KeyValueStore.init/1","type":"function"},{"doc":"","ref":"Chapter10.KeyValueStore.html#put/2","title":"Chapter10.KeyValueStore.put/2","type":"function"},{"doc":"","ref":"Chapter10.KeyValueStore.html#start_link/0","title":"Chapter10.KeyValueStore.start_link/0","type":"function"},{"doc":"This module explains how to use Task abstraction to manage asynchronous tasks. Kind of async/await on JS Book section: 10.1","ref":"Chapter10.QueryHelper.html","title":"Chapter10.QueryHelper","type":"module"},{"doc":"Simulate a database call with 1 second delayBook section: 10.1.1","ref":"Chapter10.QueryHelper.html#execute_query/1","title":"Chapter10.QueryHelper.execute_query/1","type":"function"},{"doc":"This function shows how to use Task to initiate concurrent computationVery similar to a Promise.all on JS.Task.async/1 returns a promise that is awaited by Task.await/1Book section: 10.1.1","ref":"Chapter10.QueryHelper.html#run_queries/1","title":"Chapter10.QueryHelper.run_queries/1","type":"function"},{"doc":"","ref":"Chapter10.SimpleRegistry.html","title":"Chapter10.SimpleRegistry","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Chapter10.SimpleRegistry.html#child_spec/1","title":"Chapter10.SimpleRegistry.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Chapter10.SimpleRegistry.html#init/1","title":"Chapter10.SimpleRegistry.init/1","type":"function"},{"doc":"","ref":"Chapter10.SimpleRegistry.html#register/1","title":"Chapter10.SimpleRegistry.register/1","type":"function"},{"doc":"","ref":"Chapter10.SimpleRegistry.html#start_link/0","title":"Chapter10.SimpleRegistry.start_link/0","type":"function"},{"doc":"","ref":"Chapter10.SimpleRegistry.html#whereis/1","title":"Chapter10.SimpleRegistry.whereis/1","type":"function"},{"doc":"","ref":"Database.Worker.html","title":"Database.Worker","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Database.Worker.html#child_spec/1","title":"Database.Worker.child_spec/1","type":"function"},{"doc":"","ref":"Database.Worker.html#get/2","title":"Database.Worker.get/2","type":"function"},{"doc":"","ref":"Database.Worker.html#start_link/1","title":"Database.Worker.start_link/1","type":"function"},{"doc":"","ref":"Database.Worker.html#store/3","title":"Database.Worker.store/3","type":"function"},{"doc":"","ref":"Todo.Application.html","title":"Todo.Application","type":"module"},{"doc":"Callback implementation for Application.start/2.","ref":"Todo.Application.html#start/2","title":"Todo.Application.start/2","type":"function"},{"doc":"","ref":"Todo.Cache.html","title":"Todo.Cache","type":"module"},{"doc":"","ref":"Todo.Cache.html#child_spec/1","title":"Todo.Cache.child_spec/1","type":"function"},{"doc":"","ref":"Todo.Cache.html#init/1","title":"Todo.Cache.init/1","type":"function"},{"doc":"","ref":"Todo.Cache.html#server_process/1","title":"Todo.Cache.server_process/1","type":"function"},{"doc":"","ref":"Todo.Cache.html#start_link/0","title":"Todo.Cache.start_link/0","type":"function"},{"doc":"","ref":"Todo.Database.html","title":"Todo.Database","type":"module"},{"doc":"","ref":"Todo.Database.html#child_spec/1","title":"Todo.Database.child_spec/1","type":"function"},{"doc":"","ref":"Todo.Database.html#get/1","title":"Todo.Database.get/1","type":"function"},{"doc":"","ref":"Todo.Database.html#store/2","title":"Todo.Database.store/2","type":"function"},{"doc":"","ref":"Todo.Entry.html","title":"Todo.Entry","type":"module"},{"doc":"","ref":"Todo.Entry.html#new/2","title":"Todo.Entry.new/2","type":"function"},{"doc":"","ref":"Todo.Entry.html#update_description/2","title":"Todo.Entry.update_description/2","type":"function"},{"doc":"","ref":"Todo.Entry.html#t:t/0","title":"Todo.Entry.t/0","type":"type"},{"doc":"","ref":"Todo.List.html","title":"Todo.List","type":"module"},{"doc":"","ref":"Todo.List.html#add_entry/2","title":"Todo.List.add_entry/2","type":"function"},{"doc":"","ref":"Todo.List.html#delete_entry/2","title":"Todo.List.delete_entry/2","type":"function"},{"doc":"","ref":"Todo.List.html#entries/2","title":"Todo.List.entries/2","type":"function"},{"doc":"","ref":"Todo.List.html#new/0","title":"Todo.List.new/0","type":"function"},{"doc":"","ref":"Todo.List.html#new/1","title":"Todo.List.new/1","type":"function"},{"doc":"","ref":"Todo.List.html#update_entry/2","title":"Todo.List.update_entry/2","type":"function"},{"doc":"","ref":"Todo.List.html#update_entry/3","title":"Todo.List.update_entry/3","type":"function"},{"doc":"","ref":"Todo.List.html#t:t/0","title":"Todo.List.t/0","type":"type"},{"doc":"","ref":"Todo.List.CsvImporter.html","title":"Todo.List.CsvImporter","type":"module"},{"doc":"","ref":"Todo.List.CsvImporter.html#import!/1","title":"Todo.List.CsvImporter.import!/1","type":"function"},{"doc":"","ref":"Todo.Metrics.html","title":"Todo.Metrics","type":"module"},{"doc":"Returns a specification to start this module under a supervisor.arg is passed as the argument to Task.start_link/1 in the :start field of the spec.For more information, see the Supervisor module, the Supervisor.child_spec/2 function and the Supervisor.child_spec/0 type.","ref":"Todo.Metrics.html#child_spec/1","title":"Todo.Metrics.child_spec/1","type":"function"},{"doc":"","ref":"Todo.Metrics.html#loop/0","title":"Todo.Metrics.loop/0","type":"function"},{"doc":"","ref":"Todo.Metrics.html#start_link/1","title":"Todo.Metrics.start_link/1","type":"function"},{"doc":"","ref":"Todo.ProcessRegistry.html","title":"Todo.ProcessRegistry","type":"module"},{"doc":"","ref":"Todo.ProcessRegistry.html#child_spec/1","title":"Todo.ProcessRegistry.child_spec/1","type":"function"},{"doc":"","ref":"Todo.ProcessRegistry.html#start_link/0","title":"Todo.ProcessRegistry.start_link/0","type":"function"},{"doc":"","ref":"Todo.ProcessRegistry.html#via_tuple/1","title":"Todo.ProcessRegistry.via_tuple/1","type":"function"},{"doc":"","ref":"Todo.Server.html","title":"Todo.Server","type":"module"},{"doc":"","ref":"Todo.Server.html#add_entry/2","title":"Todo.Server.add_entry/2","type":"function"},{"doc":"Returns a specification to start this module under a supervisor.See Supervisor.","ref":"Todo.Server.html#child_spec/1","title":"Todo.Server.child_spec/1","type":"function"},{"doc":"","ref":"Todo.Server.html#delete_entry/2","title":"Todo.Server.delete_entry/2","type":"function"},{"doc":"","ref":"Todo.Server.html#entries/2","title":"Todo.Server.entries/2","type":"function"},{"doc":"","ref":"Todo.Server.html#start_link/1","title":"Todo.Server.start_link/1","type":"function"},{"doc":"","ref":"Todo.Server.html#update_entry/2","title":"Todo.Server.update_entry/2","type":"function"},{"doc":"","ref":"Todo.Server.html#update_entry/3","title":"Todo.Server.update_entry/3","type":"function"},{"doc":"","ref":"Todo.System.html","title":"Todo.System","type":"module"},{"doc":"","ref":"Todo.System.html#start_link/0","title":"Todo.System.start_link/0","type":"function"},{"doc":"","ref":"Todo.Web.html","title":"Todo.Web","type":"module"},{"doc":"Callback implementation for Plug.call/2.","ref":"Todo.Web.html#call/2","title":"Todo.Web.call/2","type":"function"},{"doc":"","ref":"Todo.Web.html#child_spec/1","title":"Todo.Web.child_spec/1","type":"function"},{"doc":"Callback implementation for Plug.init/1.","ref":"Todo.Web.html#init/1","title":"Todo.Web.init/1","type":"function"},{"doc":"1 - Erlang and Elixir","ref":"chapter_1.html","title":"1 - Erlang and Elixir","type":"extras"},{"doc":"Erlang is more than a programming language, it is a development platform. It is designed by Ericsson in 1980s to solves the telecom system problems at the time, where properties like reliability, responsiveness, scalability and constant avaiability were imperative.Despite this fact, Erlang does not provide any special abstractions for telecom system, it is actually a general purpose platform that solves hard technical problems such as concurrency, scalability, fault-tolerance, distribution and high avaiability in a very unique way.Back to 90s these kind of problems just exists on the telecoms world, but today, these are the same problems that almost every large system have to deal with. And solve these kind of problems is the purpose of Erlang. Erlang has been used for decades now, it empowers various types of systems from Whatsapp to RabbitMQ, passing through multiplayer backends and Heroku Cloud System. Its a proven technology that empowers great software since late 80s.1.1.1 - High AvaiabilityErlang platform is well known by provide to the systems empowered by it the following features:Fault-tolerance: Unexpect errors happens, that is a fact. But the impact of it can be minimized. A fault tolerant system is a system where an unforeseen failure affects the minimal amount of the system's services. (eg. If Netflix has a problem with the recomendantion service we dont want the streaming service be affected by it, by any means) (eg. If a user send an input that broke the feature, idealy the other users that sent valid inputs should not be affected)Scalability: A scalable system is a system that is able handle any possible load, quicklly and ideally with no down time. It is usually do by scalling horizontally, because the vertical scale has a well defined limit where it caps.Distribution: Since the best way to scale is horizontally, its natural to this kind of system be distributed. That means that a task could be handle by many different machines, this machines are totally separate devices that works together to complete the task. But being a distributed system causes a load of challenges to solve, and thats why Erlang is so helpfullResponsiveness: A responsiveness system should keep it response time low even whith load increases, unexpected errors or occasional lengthy tasks.1.1.2 Erlang ConcurrencyErlang solves these problems using it's virtual machine called BEAM. Diferent of manny modern languages that relly on threads and OS process, Erlang takes the concurrency into its own hands.The BEAM takes control of the OS and uses its own schedulers to distribute the work for each process. Erlang process are different than OS process, Erlang process are orders of magnitude lighter than OS process, an Erlang sytem can run millions of these processes.With BEAM and process, Erlang is able to solve:Fault-tolerance: Since the process dont share any kind of memory with each other, an error on a process cant affect the other. Moreover, Erlang provides tools to detect and handle process crashes. Usually starting a new process on its place.Scalability: The no memory share rule of the Erlang process makes typical sync mechanism like, locks, mutexes or semaphores unnecessary. This makes all the interactions between this concurrent process much simpler.Distribution: There is no difference in the communication between two process on the same BEAM instance and two process in different BEAM instances. This way the communication between process in a single machine or distributed along many machines is the same.Responsiveness: BEAM process management is preemptive. It means that each process run for a brief period then it is paused. Since the execution time is small a single demanding task cant block the rest of the system. I/O operations are internally delegated to threads. Even the garbage collector is executed just inside the process when needed.1.1.3 - Server-side SystemsErlang is usually used to build serve-side systemsA complex project can be built relying just on ErlangDespite this, the Erlang built tools may not be enough for the purpose, then you should move for a mainstream tool for the job","ref":"chapter_1.html#1-1-erlang","title":"1 - Erlang and Elixir - 1.1 - Erlang","type":"extras"},{"doc":"Elixir enables to write more cleaner and compact code that runs on the BEAMAfter compile, there is no efficiency gap between the Elixir and Erlang codePure Erlang modules can be run on ElixirThere is not you can do in Erlang that cant be done in ElixirIn summary, Elixir is Erlang with more modern syntax and development tolling","ref":"chapter_1.html#1-2-elixir","title":"1 - Erlang and Elixir - 1.2 - Elixir","type":"extras"},{"doc":"The nature of frequent context switches makes Erlang a not very fast language. It's because the goal is to be reliable, keeps performance predictable and between limits. An Erlang system average response time should not vary much for diffent user load.Not prime tecnology for heavy CPU bound operationsThe ecosystem around Elixir and Erlang are yet relatively small","ref":"chapter_1.html#1-3-disavantages","title":"1 - Erlang and Elixir - 1.3 - Disavantages","type":"extras"},{"doc":"2 - Building BlocksEverything in Elixir is an expression that has a return value","ref":"chapter_2.html","title":"2 - Building Blocks","type":"extras"},{"doc":"Started by the iex command on the consoleStarts an instance of the BEAM and a interactive Elixir shellYou can type almost any elixir code on the shell and it'll workFor complex multiline operations you just have to break the expression in lines in some way that it does not form a valid expression until the end.iex(1)&gt; 2 * ( ...(1)&gt; 3 + 3 ...(1)&gt; ) / 4 3.0Documentation can be accessed in the shell with the command h it works for almost everythingAlmost everything in elixir is an expression with a return value","ref":"chapter_2.html#2-1-interactive-shell","title":"2 - Building Blocks - 2.1 - Interactive Shell","type":"extras"},{"doc":"Dynamic language, so no explicity types. Types of variables are defined by the data within themVariable assigment in Elixir language is called variable bindingsnake_case is the variable names conventionVariable names can contain '?' or '!' eg. valid_name? = falseBy convention variables with '?' are usually boolean valuesBy convention variables with '!' are usually used to variables that can contain exceptionsRebinding doesnt mutate the existing memory value. It just allocate the new value on a new memory location and reassing the symbolic to the new locationGarbage collector exists and works as expected, values in memory that can't be reached any more are eligible to the garbage collector","ref":"chapter_2.html#2-2-variables","title":"2 - Building Blocks - 2.2 - Variables","type":"extras"},{"doc":"A typical Elixir program is composed by several small functionsOrganized group of functions are called ModulesThe initial project folder structure can be initiated by running the command mix new project_nameMix have it owns code formater that can be integrated with modern text editorsComments are done with the '#' character2.3.1 - ModulesIs a collection of functions. Kind of Java Namespaces.defmodule macro creates a moduleElixir source files use de .ex extensionA single .ex file can contain multiple modules, but a module must be defined in a single fileModules inside modules are accessible by the '.' notation and no special relation is built. Just syntax convenienceThe character '.' is avaiable to name modules but it is just a syntax convenience. No special relation are built between the modules after the compile.CamelCase is the module name convention2.3.2 - FunctionsEvery elixir function must be defined inside a modulesnake_case is the function name conventionAs variables the characters '?' and '!' are allowed tooBy convention variables with '?' are usually used when it returns a boolean valuesBy convention variables with '!' are usually used to fucntions that may rise runtime errorsdef macro is used to create functionsFunctions with no arguments can have their parentheses ommited in the declarationThere is no explicit return in Elixir, instead the return value of a function is the return value of it last executed expressionThis feature almost force the functions to be simpleThere are some condensed syntax for short functions declarationsParentheses in function calls can be omitted but it is not the conventionIf a function resides in the same module that it is being called the module name can be ommited2.3.3 - Function ArityThe arity of a function is the number of parameters it receivesThe unique identifier of a function is: Module + Name + ArityFunctions with the same module and name but different arity are completely different functions, totally independent from one anotherA usual pattern in Elixir is that lower arity function delegates work to higher arity functions. (eg. Implemented on Geometry module)Default parameter values can be generated with the // operator, but remember it generates multiple separate function.Because of it, it is not possible to a function receive a variable number of argumentsIt's possible tho to have function overload with multiclauses functions. See 3.2.12.3.4 - Function visibilityFunctions declared using the def macro are public and can be called anywhere in the codeTo create private functions should use defp macro, then it'll be accessible only inside the module2.3.5 - Import and AliassesYou can always call a public function using the syntax ModuleName.function_name()If you want to ommit the ModuleName part you can import ModuleName on the startIf you want to &quot;rename&quot; a module you can alias ModuleName, as: MyModuleName on the start2.3.6 - Module AttributesUsed usually as module constants eg. @pi 3.14 or registered as metadata about the codeConstants just exists in compile time, replacing all the references for its valueRegistered attributes such as @moduledoc are kept in the binary and can be accessed at runtimeMany Elixir tools knows how to interpret such registered attributes to generate usefull stuffs like intelisense, documentation and type specifications","ref":"chapter_2.html#2-3-code-organization","title":"2 - Building Blocks - 2.3 - Code Organization","type":"extras"},{"doc":"Elixir types can always be compared with the &gt; and &lt; operators, even when they are of different typesnumber &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; binary2.4.5 - Data ImmutabilityThe general idea of data immutability leads to a thought that this could be inneficient memory wise, but actually in most of the cases most of the data is shared by the old and the new version.This is easily demonstrate with lists modification, where the tail of the modificated element can be shared without any problems.Worth to mention that some data copy is always be present, but the benefits of the immutabillity largelly surpass this downside. The two main benefits of it are:Side efect free functions that are easier to analyze, predict and testData consistency that leads to the ability to perform atomic in-memory operations2.4.1 - NumbersUsually works as expected.'/' operator always returns a Float2.4.2 - AtomsNamed constants. (eg. [:an_atom , :another_atom, :&quot;an atom with spaces&quot;])Compose of two parts text and valueEfficient memory and performance wise because it is a link to the value and no the value it selfEnables repeat constants without overload memory neither the code readabilityAliases are syntax sugar for AtomsBooleans are Atoms2.4.2 - Nil and truthyNil is an AtomNil and false are falsy and all the rest truthyShort circuits are avaiable2.4.3 - TuplesEg. person = {&quot;bob&quot;, 25} | age = elem(person,1) | put_elem(person, 1, 26)Tuples are untyped structuresUsually used to group a fixed amount of elements togetherTuples can be manipulated by the Kernel moduleChanges on the tuple does not affect the original data just the references. (Data is always immutable)2.4.4 - ListsEg. prime_number = [2,3,4,7]Used to manage dynamic, variable-sized collections of dataLooks like an array but in fact are singly linked listsBecause of this, most of the operations on lists are O(n), length(list) includedCan check if some element is on a list with the operator in (eg. 6 in list)Can concatenate two lists with the ++ operator (eg. [1,2,3] ++ [4,5,6])Lists can be manipulated with List module functionsChanges on the tuple does not affect the original data just the references. (Data is always immutable)Lists are recursively composed by head and tail structureThis recursive structure are useful in many real use cases. eg. this functionBecause of this, insert a new element on the begining of a list is O(1) while insert on the end is always O(n)2.4.6 - Mapseg. empty_map = %{} | squares = %{1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9} | squares = Map.new([{1,1},{2,4},{3,9}])It is a key/value storeUsed to manage dynamically sized key/value structuresUsed to manage simple records with a couple well-defined named fieldsDynamically sized maps are managed by the Map module of the kernel (eg. Map.fetch(squares,2) | Map.get(squares, 2))Structured data are usually managed by a notation similar to normal OO objects. (except for updates!)For structured data is a common pattern provide all fields of the object as Atoms on the initialization and therefore just use the update syntaxWhen keys are Atoms some syntax sugar is avaiable. eg. bob = %{name: &quot;bob&quot;, age: 25}|bob.name2.4.7 - Binaries and bitstringseg. &lt;&lt; 1,2,3 &gt;&gt;Are chunks of bytesDon't need to be a multipler of 16. But the representantion will still be in a 8bit normalized formWhen it is not a multiple of 8 it is called a bitstring2.4.8 - StringsElixir does NOT have a dedicated String type. Instead it is represented either as a binary or a list typeInterpolation syntax is \#{CODE HERE}Binary strings uses &quot;Binary strings can be concatenated same way as binaries with the &lt;&gt; operatorUsually binary strings are managed by the String module of the kernelChar lists uses 'Char lists are a list of integers [65,66,67] == 'ABC' results trueMost operations of the String module will NOT work with char listSome operations only works with char list, usually the pure erlang onesIn general its better to endorse the use of binary strings over char lists, except when some third-party library requires the use of char listsIt's possible to convert one type into another one2.4.9 - FunctionsAnonymous functions are allowed, but the convention to write is different from the named functions. Their parameters dont have parentheses.This is important because on multiclauses lambdas all the clauses are listed below it, so it is cleaner to do soFor code clarity purpose when an anonymous function is called it need to be called with a . (eg. anonymous_func.(param1, param2))The fact that functions can be stored in variables allow to them be passed as arguments to parameterize generic logic. Similar to Javascript callback functions on methods like Array.forEachThe capture operator &amp; is used to simplify the code, diminishing the noisy, because with it there is no need to create a trivial function that just foward values to another function without any real logicThe capture operator can also be used to shorten lambda definitions for simple functions. lambda = &amp;(&amp;1 * &amp;2 + &amp;3)Anonymous functions have access to all variables from the outside scope. Once the function is created, the function points to the outside variable values on the moment of the creation (it does not change even if these variables change are reassigned later), and hold its value until the variable that contains the anonymous function is reassigned wich makes the outside variables value used inside the function NOT eligible for garbage collectioniex(1)&gt; mut = 2 2 iex(2)&gt; lambda = fn -&gt; IO.puts(mut) end #Function&lt;45.97283095/0 in :erl_eval.expr/5&gt; iex(3)&gt; lambda.() 2 :ok iex(4)&gt; mut = 4 4 iex(5)&gt; mut 4 iex(6)&gt; lambda.() 2 :ok iex(7)&gt; lambda = fn -&gt; IO.puts(mut) end #Function&lt;45.97283095/0 in :erl_eval.expr/5&gt; iex(8)&gt; lambda.() 42.4.10 - Other built-in typesReference: Unique values genereated inside a BEAM instancePid (process identifier): Used to idenfiy erlang process ans cooperate between concurrent tasksPort Identifier: All the communication with the outside world is doing through it2.4.11 - High level typesRange: An enumerable for simple integer ranges, similar to python's range. (eg. range = 1 .. 33)Keyword lists: A special case of list, when all its elements are a two-element tuple and the first element of the tuple is an Atom and have a usage similar to Maps but can have multiple values for the same key and the order could be defined by the user. Mostly used in functions with optional parameters. (eg. [{:monday, 1}, {:tuesday. 2}])MapSet: The goto structure when dealing with sets. Managed by the MapSet module.Date and Time: Composed by 4 modules (Date, Time, DateTime, NaiveDateTime) and can be created by sigils (~D for date, ~T form time, ~N for naive date time)2.4.12 - IO ListsSpecial kind of lists.Usually used to incrementally build stream of bytes and forwarded it to an I/O deviceEach element is either an integer between 0 and 255, a binary or an IO ListThis list is usually build as a recursive structs like this:iolist = [] iolist = [iolist, &quot;This&quot;] iolist = [iolist, &quot; is&quot;] iolist = [iolist, &quot; Sparta!&quot;]This recursive build method makes all the insertion operations on the list O(1)","ref":"chapter_2.html#2-4-type-system","title":"2 - Building Blocks - 2.4 - Type System","type":"extras"},{"doc":"Logical operators works as expected. (eg. == | != | &gt;= | || | &amp;&amp;)Strict equality are avaiable just like in JavaScript (eg. === | !==)Short circtuit operators works as expect. (eg. || | &amp;&amp;)Unary operator ! is avaiable and works as expectedThe pipeline operator |&gt; takes the value on the left and passes it as the first argument of the function on the right.Pipeline operator is usefull when dealing with a serie of function transformations on dataMost operator are actually functions (eg. 1 + 2 is the same as Kernel.+(1,2))Although anyone should right Kernel.+(1,2) but this enable the usage of operator functions in anonymous function using the capture operator &amp; and use them on the enumeration and stream functions","ref":"chapter_2.html#2-5-operators","title":"2 - Building Blocks - 2.5 - Operators","type":"extras"},{"doc":"Too advanced for now. Let's learn it later. TODO: Learn more about macros and read the book: Metaprogramming ElixirOne of the most important features in elixirAlthough it's importance, macros should not be over used. Actually it's considered a bad practice use macros when it is not necessary.From Official Elixir DocsMacros should only be used as a last resort. Remember that explicit is better than implicit. Clear code is better than concise codeEnable the creation of compile-time code transformersRelies on the quote unquote mechanism describe on https://elixir-lang.org/getting-started/meta/quote-and-unquote.htmlMacros parameters are not resolved as normal function parameters, they actually are quoted, and the result of the macro is a quote tooQuote and unquote mechanism works because almost every elixir command can be decomposed as a commom standarzied list structure","ref":"chapter_2.html#2-6-macros","title":"2 - Building Blocks - 2.6 - Macros","type":"extras"},{"doc":"Elixir runtime is a BEAM instanceAfter the compile and the system's start, Erlang takes full controlBEAM is a VM, so like JVM it takes control of the system resources and acts as a middleman between the code and the machine2.7.1 - Modules and FunctionsVM keeps track of all modules loaded in memoryWhen a function is called from a module, first it checks wheter the module is loaded. If not load it. Then, execute the functionAlthough you can write many modules on the same file, when it is compiled each module has it's own Elixir.name_of_the_module.beam fileModules are always compiled even if it is defined on IEX. Just its binary will be sotred on memory instead disk.Manual compiled modules elixirc source.ex can be used by elixir tools if they are in the same folder, some code path (defined with iex -pa my/code/path)Pure Erlang compiled modules have pretty much the same behaviorPure Erlang modules are Atoms, and because of this have a different naming system. pure_erlang_module.beam instead the elixir version Elixir.elixir_module.beamAt runtime module names are atoms and somewhere on the disk is a module_name.beam file where module_name is the alias of Elixir.module_nameFunctions can be called dynamically in runtime using the kernel function apply. (eg. apply(IO, :puts, [&quot;Dynamic call&quot;]))2.7.2 - How to start the runtimeIEX:Used most for casual tests and interact with a on going Elixir systemWhen the interactive shell is started, the BEAM instance is started underneath too. THe elixir shell takes the input interprets it and show to use the result of the expression that ran on BEAM.Because of the &quot;interprets&quot; part of the IEX, its important to say that it's not a good idea makes performance tests on the IEX. The production code will always be compiled.ScriptsThe elixir command can be used to run a single elixir fileAll modules are compiled and stored on the memory all other code is interpreted and run on the BEAM that is stopped once is nothing more to runYou can prevent the BEAM to stopped after there is no more code to run with the option elixir --no-halt script.exsThis is usefull when your script just load the modules and forward the real work to concurrent tasksMix toolUsed to manage projects that are composed by multiple source fileBest tool for production ready systemsHave several commands that helps build production ready systems. Such as mix test , mix run, mix docs, mix compile, and much more.","ref":"chapter_2.html#2-7-elixir-runtime","title":"2 - Building Blocks - 2.7 - Elixir Runtime","type":"extras"},{"doc":"3 - Control FlowConditionals and loops works diffenrently than expectedIf and cases are often replaced by multiclause functionsThere is no classical loop like whilesAthough it is possible to solve problems of any complexity with Elixir","ref":"chapter_3.html","title":"3 - Control Flow","type":"extras"},{"doc":"= operator is NOT a assignment, it is a matchIt makes manipulate complex variables a lot easierIt even enable you to build elegant declarative-like conditionals and loopsThe result of the match expression is always the value of right-side termWhen the term does not match to the pattern expectations on the left an error is raisedCan be recursivelly nestedOn the left is the pattern and on the right is the termVariables on the pattern are bound to term valuesFunctions arguments are patterns3.1.1 - Match OperatorAssigment like operations is the most basic use of the match operator =Although the expression looks like an assignment and can be treated like one, in fact it's something more complex going onA variable is a patter that always match with any term3.1.2 - Matching Tuplesiex(14)&gt; {date, time} = :calendar.local_time() {{2020, 6, 13}, {19, 27, 26}} iex(15)&gt; {year, month, day} = date {2020, 6, 13} iex(16)&gt; {hour, minute, second} = time {19, 27, 26}This kind of match is useful to bind individual tuple elements to separate variablesWhen using this match you are saying that the term should be a tuple with 2 elementsThe variable date will be bound to the first element of the tuple and the time to the secondKind of JavaScript object destructuring but instead of object attributes the destructure matchers are the position on the tuple3.1.3 - Matching Constantsiex(2)&gt; person = {:person, &quot;Bob&quot;, 25} {:person, &quot;Bob&quot;, 25} iex(3)&gt; {:person, name, age} = person {:person, &quot;Bob&quot;, 25}1 = 1 it surprisingly worksThe usage of constants on the pattern is usefull to guarantee that the term is what you expectedThis pattern is very common on Elixir, where the first element of a tuple is a Atom that defines the tuple &quot;&quot;type&quot;&quot; {:ok, content} | {:error, reason}When constants are used on the pattern you are making sure that the specific part of the term contains that value and you can relie on this information later3.1.4 - Matching VariablesVariables always match with the left side term and are bound to the matched valueYou can skip terms on tuples with the &quot;&quot;. eg. `{, time} = :calendar.local_time()`The same variable can be matched multiple times. This enforce all the ocurrences has to be equal.iex(2)&gt; {amount,amount,amount} = {123,123,123} {123, 123, 123} iex(3)&gt; {amount,amount,amount} = {123,123,1} ** (MatchError) no match of right hand side value: {123, 123, 1}To use the variable value instead of bound it, you can use the pin operator &quot;^&quot;.iex(5)&gt; expected_name = &quot;bob&quot; &quot;bob&quot; iex(6)&gt; {^expected_name, _} = {&quot;bob&quot;, 25} {&quot;bob&quot;, 25} iex(7)&gt; {^expected_name, _} = {&quot;alice&quot;, 25} ** (MatchError) no match of right hand side value: {&quot;alice&quot;, 25} This is usefull when you need to build a pattern at runtime3.1.5 - Matching ListsWorks similarly to tuplesMatching lists is usually done relying on the recursive nature eg. [head|tail] = [1,2,3]This pattern is usually useful when matching function arguments3.1.6 - Matching Mapseg. (%{age: age, works_at: works_at} = %{name: &quot;Bob&quot;, age: 25})Worsk similary to JavaScript object destructuring3.1.7 - Matching Binaryseg. &lt;&lt;b1,b2,b3&gt;&gt; = binaryYou can use the &quot;::&quot; operator to define different sizes eg. &lt;&lt;a :: 4, b :: 4&gt;&gt; = &lt;&lt;155&gt;&gt;On binary strings the match works kind of like operationsiex(13)&gt; command = &quot;ping www.example.com.br&quot; &quot;ping www.example.com.br&quot; iex(14)&gt; &quot;ping &quot; &lt;&gt; url = command &quot;ping www.example.com.br&quot; iex(15)&gt; url &quot;www.example.com.br&quot; 3.1.8 - Compound MatchesThe fact that the result of a match expression is the right term value, enable elegant onelinersiex(20)&gt; {date , {hour, _ , _}} = :calendar.local_time() {{2020, 6, 13}, {20, 24, 35}} iex(21)&gt; date_time = {date , {hour, _ , _}} = :calendar.local_time() {{2020, 6, 13}, {20, 25, 25}} iex(22)&gt; {date, _} = {_ , {hour, _ , _ }} = :calendar.local_time() {{2020, 6, 13}, {20, 26, 9}}","ref":"chapter_3.html#3-1-pattern-matching","title":"3 - Control Flow - 3.1 - Pattern Matching","type":"extras"},{"doc":"The pattern matching feature is used in the specification of a function argumentsThis enable a input validation at runtime on function callsFor instance if you want a tuple containing 2 elements and receive just a tuple with 1 element the call will raise an errorThe patter matching feature on function arguments empowers one of the most important Elixir features, multiclause functions3.2.1 - Multiclause functionseg. this functionEnable the overload of a function by the specification of multiple clausesWhen you have multiple functions with the same name and arity, you have a multiclause functionWhen a multiclause function is called, the runtime tries to match all of the clauses in source code order, the first one that succeeds executesAll the functions are one unique function. Despite the fact that in the source code it appears to be different functions and have completely different implementations, from callers perpespective it is all one unique function.Even the capture operator &amp; captures all the clausesClauses of the same function MUST be always kept together in the source code. Even the compiler emits a warning when it is not3.2.2 - Guardseg. this functionGuards extends the multiclause behaviour by enabling other conditionals on the clause in adition to the patter matchingNot every function can be called from guards, are allowed:Comparisson operators. eg.&lt;=Boolean operators. eg. andArithmetic operators. eg. +Type check functions from Kernel module. eg. is_number/1If an error occurs during a guard validation, the clause returns false, and the runtime proceeds to the next clause","ref":"chapter_3.html#3-2-matching-functions","title":"3 - Control Flow - 3.2 - Matching Functions","type":"extras"},{"doc":"3.3.1 - Multiclause branchingeg. this functionAs seen, patter matching on multiclause functions can be used to build conditionals that are applied on inputs parameters3.3.2 - Classical branchingIfiex(1)&gt; if true, do: ...(1)&gt; &quot;Success&quot;, ...(1)&gt; else: ...(1)&gt; &quot;Failure&quot; &quot;Success&quot;Works as expectedOne-liners can be done as if condition, do: somehting_to_do, else: another_thing_to_doThe return value of an if statement is the return valur of the executed block, if no block is executed the result is nilUnlesssame as if(!condition)Condeg. this functionCan be explained as if else ifThe first condition that is true has its code executedIf no condition is valid, raises an errorCaseSimilar to switch-case on mainstream languagesUses patter matching instead of simple bollean expressionsThe first pattern that is matched has its code executedIf no pattern is matched, raises an errorCan serve as a substitute to multiclause functions on simple tasks3.3.3 - The With Special Formeg. this functionUseful to chain pattern matching expressions and return the result value of the first one that failsIf all clauses are matched the do block is executedGuards can be used on patterns as wellAll variables declared inside with are restricted to that scopeAn else block can be used in case of failures","ref":"chapter_3.html#3-3-conditionals","title":"3 - Control Flow - 3.3 - Conditionals","type":"extras"},{"doc":"Definitely doesn't work as expectedThe unique looping tool in Elixir is recursionOther high-order functions that are usefull to do iterations are built in on top of recursionsAlthough recursion is the main loop building block, high-order functions provide abstractions to deal with it for recorrent simple tasks3.4.1 - Iterating With Recursioneg. this functionUsually are built with multi-clause functions. eg. this functionFirst clause is the recursion stop condition and the other clauses the general casesThe usual memory problem with long recursions is solved in Elixir by tail-call optimization3.4.2 - Tail Function Callseg. function 1 | function 2 | function 3A tail call happens when the last expression of a function (it's return value) is a call to another function(even it self, in case of recursive tail functions)A tail calls works with any branching constructs such as if or condIf the last expression is something like 1 + call_to_a_func() this is not a tailThe optimization consists in instead of make a stack push for new function calls something like a goto occursThis is possible because since the function final value is the value of the next function being called, no context needs to be stored for later computationThis feature is especially good in recursive functions, since recursive calls don't allocate extra memory a recursive tail function can run, virtually, foreverThis kind of function is the appropriate solution for large iterationsTail recursions are kind of the substitutes for traditional loops, it have an accumulator, an iteration step on the general cases clauses and the stop condition on the first clauseThe downside is that sometimes the classical recursion is more elegant solution than the tail recursion, so it is a matter of readabillity x performance3.4.3 - Higher Order FunctionsThis kind of functions abstract the recursion complexity, but in the end it's all recursionBy definition, a higher-order function is a function that do at least one of this 2 things:Takes one or more functions as inputReturns one or more functionsEnum is the goto module to work with enumerablesEnum has similar functions as JavaScript Array Prototype that works on all enumerable types on elixirThe capture operador &amp; is very usefull to declare simple functions as parameters to highorder functions. eg. this function3.4.4 - Comprehensionsiex&gt; for i &lt;- [:a, :b, :c], j &lt;- [1, 2], do: {i, j} [a: 1, a: 2, b: 1, b: 2, c: 1, c: 2]Kind of a python for but with some different syntaxi &lt;- [:a, :b, :c] is the generator termMultiples generator can be nested to simulate a nested loopSome problems has a more elegant solution when written wih comprehension, especially cross-join problems3.4.5 - StreamsStream is a special type of enumerable, it is a lazy enumerableThe functions of Stream module usually receives any enumerable as an entry and returns a streamA stream is kind of a description of the operations that when executed will produce the resultIt means that the values are generated only when requested, and not before hand, this has 2 major benefits:Memory optimization: Since all the operations can be applied 1 element a time, the whole list is never on the memoryIterations optimization: Series of transformations can be done with a single iteration over the list instead of manyThis laziness property are very usefull when the problem demands multiple transformations on a large list. eg. this moduleThe laziness is so deep that you can even calculate values one by one with the function Enum.take/2","ref":"chapter_3.html#3-4-loops-and-iterations","title":"3 - Control Flow - 3.4 - Loops and Iterations","type":"extras"},{"doc":"4 - Data AbstractionData abstractions are built as pure elixir modulesThese modules works as an abstraction of the data type. (eg. If you want to work with a list data type, you use the List module)This kind of modules have 2 types of functionsModifier: Transform the input data, and return the modified version that is same type of the input. eg. String.upcase/1 and List.insert_at/3Query: Analyze the input data and return some piece of information about it in a different data type. eg. String.length/1 and List.first/1If struct is not used, there is no difference between a map and the high level data structure","ref":"chapter_4.html","title":"4 - Data Abstraction","type":"extras"},{"doc":"Higher level abstractions are built with the basic building blocksAlthough the abstractions are in fact some built in types, the user of the module should not rely on itThese modules free the user of the concerns like implementation or data structuresThe separation of concerns between modules are kind of similar to OO languagesBy convention this kind of modules have a function called new that create and return a new &quot;instance&quot; abstracted data4.1.2 - Composing AbstractionsJust like in OO languages, a usual pattern in elixir is to separate the concerns in different modules.TODO: Add reference to TodoList project4.1.3 - Structuring Data With Mapseg. this moduleTo avoid changes in functions signatures, it is a usual pattern use a map as a single data structure to all the entriesInstead of expect something like module.fun(arg1,arg2,arg3) you expect module.fun(%{a: arg1, b: arg2, c: arg3})The entry map must contains the expect keys to be used inside the module's functions4.1.4 - Abstracting With Structseg. this moduleStructs can be distinguished from any other data typesThe defstruct macro allow the creation of specific data structures that are bound to a specific moduleOne module can only have one struct, and one struct can only exists inside a modulePatter matching works on structsBy use pattern matching like fun(%struct{a: a, b: b}) it is enforced the usage of an instance of the struct as the entry dataStructs are in fact maps, so any Map module's function should work on itDespite it, Enum module's functions do not work, because the struct is an abstraction defined inside the module and should behave as defined inside of it. So you must define inside the module if and how the struct is enumerable or notStructs are maps, but always have a special key __struct__Because of it a struct pattern can not match a plain object. eg %struct{} = %{a:1, b:2} raises a match errorBut a plain map pattern can match a struct. eg %{} = %struct{a: 1, b: 2} succeedsRecords are an alternative from structs that uses tuples instead of maps, many pure erlang modules uses records as interfaces4.1.5 - Data VisibilityAll the data structure is always visible to the module's user. There is no private data structureIn this sense, encapsulation work different. Instead of private attributes and methods, elixir module as whole is reponsible for manage that kind of data, although you can see it data structure, you should not work on it from out side the moduleThis data transparency is useful for debugs purposeDespite this, as a module's client you should not rely on the internal data structure representationThe only guarantee of these abstraction modules is that the functions will work if an instance of a proper data structure is sent as an entry","ref":"chapter_4.html#4-1-abstracting-with-modules","title":"4 - Data Abstraction - 4.1 - Abstracting With Modules","type":"extras"},{"doc":"Because of the immutable nature of data the updates on hierarchical data has to be done by update the specific field and then all of the parents recursivelyUsually it is done with several simple functions, wich one responsible for a specific part of the update and the more specific functions delegates to the more general onesInstead of doing these several functions, the macro put_in/2 is avaiable for this purposeThere are similar macros for retrieving data too. eg. get_in/2These kind of macros relies on the Access module","ref":"chapter_4.html#4-2-hierarchical-data","title":"4 - Data Abstraction - 4.2 - Hierarchical Data","type":"extras"},{"doc":"The basic way of doing polymorphism in elixir is with protocols4.3.1 - Protocol BasicsA protocol is kind of a OO interfaceIt is a module where a functions is declared but not implementeddefprotocol String.Chars do def to_string(thing) endData types that implements the protocol can use all the functions defined by itIf protocol function is called with some data type that does not implement the protocol, an error is raised4.3.2 - Implementing Protocols## Code of the TodoList project defimpl String.Chars, for: TodoList do def to_string(todo_list) do &quot;You have \#{todo_list.auto_id - 1} tasks to do&quot; end endElixir most basic functions relies on protocolEach protocol has it's own set of functions that must be implementeddefimpl macro is used to start the implementationIn defimpl you must specify wich protocol will be implemented and the corresponding data typeOn the do-end block are the specific funtions implementationsProtocols implementations do not need to be part of any specific moduleBecause of it, you can implement protocols even for data types that you don't have access to the source codeBuilt-in Protocols## Code of the TodoList project defimpl Collectable, for: TodoList do def into(original) do {original, &amp;into_callback/2} end defp into_callback(todo_list, {:cont, entry}) do TodoList.add_entry(todo_list, entry) end defp into_callback(todo_list, :done) do todo_list end defp into_callback(_, :halt) do :ok end endElixir have some built-in protocols that are very useful, check docs for details. eg. Enumerable,Collectable,StreamBy implementing the Enumerable protocol, your high level data structure gain access to all the Enum functions for freeBesides built-in protocols you can build your own protocols","ref":"chapter_4.html#4-3-polymorphism-with-protocols","title":"4 - Data Abstraction - 4.3 - Polymorphism With Protocols","type":"extras"},{"doc":"5 - Concurrency PrimitivesElixir is all about building bighly avaiable systems, which means a system that have 3 important features:Fault-tolerance: Minimize, isolate and recover from unexpected errorsScalability: Cappable of handle more trafic by horizontally scalling without redeploysDistribution: The system runs on multiple machines, so one machine crash does not impact the whole systemConcurrency vs ParallelismConcurrency means independent execution contexts, but not necessarlly ParallelismParallelism means that two tasks are executed at the same timeParallelism can not be done in a single CPU core machineAll parallelism is congruent but not all concurrency is parallel","ref":"chapter_5.html","title":"5 - Concurrency Primitives","type":"extras"},{"doc":"The basic building block of concurrency on BEAM is a processA BEAM process is different from a OS process, BEAM process is much lighter and cheaper to built and maintainAll the processes are handle by BEAM schedulersBy default, BEAM allocates 1 scheduler for each CPU core on the machine it is runningEach scheduler has it's own thread of executionThe entire BEAM lives in a single OS processSchedulers distributed the computational power equally among all the process handle by it, in an interchangeable and preemptive mannerProcess are REALLY light, the virtual limit imposed by the VM is 134.000.000 processesProcess do not share any memory with each other, even if they are under the same schedulerProcess communicate by to each other sending messages","ref":"chapter_5.html#5-1-concurrency-in-beam","title":"5 - Concurrency Primitives - 5.1 - Concurrency In BEAM","type":"extras"},{"doc":"eg. this moduleUseful to paralelize work such as database queries or computation when the server machine has multiple coresUseful to separate execution contexts to achieve concurrency5.2.1 - Creating a ProcessNew process can be created by the kernel's function spawn/1spawn/1 receives a function to be executed by the new process and returns it's pidA useful technique to pass data between process is by using the closure mechanism on it's creation. eg. this functionAll the data passed to the process is deep copiedBecause of concurrency, order among multiple processes is not a guarantee5.2.2 - Message PassingThe only way two process can exchange data is through messagesThe content of a message can be litreally anything that a variable can holdMessages are send with the send/1 kernel's functionAll the message data is deep copied to the receiver's inboxThe process inbox is a FIFO queue limited only by the memoryMessages are consumed from the inbox in the order received, and can only be removed once it is consumedWhen a new process is spawned it must know the caller pid if the caller need the result value of it computation, to accomplish this the caller must embed his pid, wich can be obtained using self/0, into the new process. eg. this functionMessages are received by using the receive macro, wich works similar as case. eg. this functionreceive takes multiple patterns and tries to match every message on the queue, from oldest to newest, the first one that matches has his code block executedIf any message matches, the process waits until the next message arrive, and checks it.To set a kind of timeout use the after macro, this way the process will not wait foreverReceive messages takes no action from the receiver, so no block or interrupt happensBecause of concurrency, order among messages is not a guarantee","ref":"chapter_5.html#5-2-working-with-process","title":"5 - Concurrency Primitives - 5.2 - Working With Process","type":"extras"},{"doc":"Beyond do async work, process can manage CPU bound operations too and being used to manipulate dataServer process works kind of OO objects. They have a state that could be manipulated overtimeSince processes are concurrent, multiple objects can run at the &quot;same time&quot;5.3.1 - Server ProcessIt is a process that run indefinitely and can handle messages, kind of an end-pointServer processes are kept alive indefinitely by a tail loop recursion. eg. this functionThe loop, waits for a message to handle, when received handle it and goes back to wait the next messageWait for a message do not consume any CPUServer processes have 2 type of functionsInterface functions: Functions that are public and are called by the clients, the code inside these functions is executed on the client so functions like self/0 are evaluated with the client pid. These functions are usefull to abstract implementation details and communication protocols away from the client. eg. this functionImplementation functions: Functions that are private and always run on the server, these functions are responsible for the implementation details it self. eg. this functionThere is no relation between modules and processes, functions from the same module can run in different process, such as the interface x implementation example aboveGenServer can be used to simplify the development of server processesServer processes are internally sequential, this means that all the messages send to it will be handle in order, one at a timeBecause of this feature, a server process can be considered as a sync point. Use it when multiple actions needs to happen in a sync mannerThis sync feature can be bad sometimes(eg. database server), so to get around it you just have to start multiple servers, kind of a pool, and paralelize everything that you could5.3.2 - Immutable Statethis moduleThe state is passed through the loop function parameters5.3.3 - Mutable Statethis moduleThe state is passed through the loop function parameters and changed by the message handler functionsThis aproach can feels like an mutable data structure, but it is notPure functional abstractions are used inside the server process to handle all the requestsIn this way, the server process is just a controller of a pure functional abstraction that can be manipulated by other processes5.3.4 - Complex StateSame as mutable state, but the handle functions pass more complex data to the loop5.3.5 - Registered ProcessesServer process can have a local inside a BEAM instanceThis name enable a simplification of the server process interface by removing the server pid repetition on the interface functionsThis is done by Process.register/2","ref":"chapter_5.html#5-3-stateful-server-process","title":"5 - Concurrency Primitives - 5.3 - Stateful Server Process","type":"extras"},{"doc":"5.4.1 - Process is SequentialAlthough multiple processes can run in paralel, internally a single process is always sequential, handling the incoming messages in the exact order that they arrivedBecause of the sequential nature of a process,it can become a bottle neck if too many processes are sending messages to it, affecting the overall system response timeTo solve this bottle neck problem that are two options:Optimize the code, this option is the main one and should always be the first oneSplit the process in multiple processes (only works on multi core machines), this should be the last resort5.4.2 - Process MailboxMailboxes are theoretially unlimited, just capped by the system's memory avaiableIf a process is receiving more messages per second than it can handle, it's mailbox will grow indefinitelyThis indefinitely grow can lead, ultimately, to a system crash by consuming all the system's memoryAnother way of grow the mailbox is when a process receive messages that it can not handleThis unhandled messages stack up on the mailbox causing the process to iterate over all of them when a new message arriveA way to solve the unhandled messages problem is always have a fallback handler:def loop receive {:message, data} -&gt; handle_message(data) other -&gt; log_unknown_message(other)BEAM provides tools for analyzing processes mailboxes at runtime. Will be discussed in chapter 135.4.3 - Share Nothing ConcurrencyAll the data sent to a process is deep copied to itVariables in a function closure tooBe aware of multiple complex huge data passes between multiple processesA special case where deep copy do not occur is with binaries larger than 64 bytesThese binaries are stored on a special shared binary heapThe benefits of share nothing are:Simplifies the code: Because processes do not share memor, no complex operations such as mutexes and semaphores are neededOverall stability: A process can not compromise the other process dataEfficient garbage collection: No &quot;stop the world&quot; garbage collector, it runs inside each process when needed5.4.4 - Scheduler Inner WorkingsEach BEAM scheduler is a OS threadBy default, BEAM runs as many schedulers as logical processors avaiableErlang flags can be used to change many behaviours of BEAMEach scheduler manages the execution of many processesInternally each scheduler keeps a list of processes providing each of these processes a execution time window (~2.000 reductions)Because of the preemptive nature of schedulers no long running process can impact the system overall responsivenessSome operations make the process yield the process back to the scheduler, such as sleep and IO operations","ref":"chapter_5.html#5-4-runtime-considerations","title":"5 - Concurrency Primitives - 5.4 - Runtime Considerations","type":"extras"},{"doc":"6 - Generic Server Process","ref":"chapter_6.html","title":"6 - Generic Server Process","type":"extras"},{"doc":"Much of the work and boilerplate involved in the coding of a server process can be implemented as an abstractionThat is exactlly what GenServer and I built my own abstraction on this module is built for, simplify server process code with an abstraction for functionallities like spawn a new process and run the infinite loopThe relation between the generic server implementation and the callback module is something like the generic manage the flow of control (processes spawns, the infinite loop, send and receive messages, keep the process state) and the callback module is responsible for the implementation (define the initial state, define the messages that the processes understand and handle these messages)Basically the generic server implementation manages all the non interface functions of a normal server process and on the other hand the callback module manages all the interface functionsBecause of this, the code of a server process is much more concise and easy to understand when it takes advantage of a generic server abstraction, because it only has to deal with what is relevant to it, the implementation it self and reuse generic abstract functions to run as a server process","ref":"chapter_6.html#6-1-building-it","title":"6 - Generic Server Process - 6.1 - Building It","type":"extras"},{"doc":"GenServer is a built in feature of erlang that enable the creation of generic server process whith rich feature supportsSystem that relies on GenServer are, by design, ready for work in a distributed envinronmentGenServer relies on OTP Behaviours6.2.1 - OTP BehavioursBehaviour is a generic code that implements a common patternKind of interfaces on OO worldA behaviour expect a set of functions to be implemented and exported by a callback moduleBehaviours guarantee that if your callback module implements the expected set of functions, your module will be ready to be empowered by all the BEAM and Erlang benefitsStandard Erlang OTP Behaviours:gen_server: Server processessupervisor: Error handling and recoveryapplication: Components and librariesgen_event: Event handlinggen_statem: Finite state machine on server processesElixir has its own wrappers for the most commom behaviours6.2.2 - Plugging Intoeg. this moduleThe macro use is frequentlly used to get default implementations for required callback functions at compilation time use GenServerThen you can overwrite the default implementations with specific ones6.2.3 - Handling RequestsThe basic callback functions to work with GenServer are:init/1: Used in the server initial state definitionhandle_cast/2: Handle async calls to the serverhandle_call/3: Handle sync calls to the serverThe general idea behind it is pretty similar to our self implemented server processIn order to work with it perfectly just remember to follow the docs to implement the corrects signatures and responses formatsGenServer.start/2 is synchrounously, so the client that initializes it will be blocked until it fully launchedGenServer.call/2 does not wait forever, by default it just waits 5 sec6.2.4 - Handling Plain MessagesMessages sent to the server process via GenServer.call/2 and GenServer.cast/2 have more data than the simple message dataIt contains a kind of message type identification, such as &quot;call&quot; or &quot;cast&quot;, because of it GenServer can handle specific messages in different waysSometimes you need to handle messages that are not specific to GenServer, which means it does not contains a :call or :cast attached to itFor handle this type of messages you must use the handle_info/2 callback function. eg. this functionAll the messages that arrive to the server that are not call neither cast are handled by handle_info/26.2.5 - Other GenServer Featureseg. this moduleThe attribute @impl indicates that the following function must implement a callback function, this enable compile time checkingServer process can be named and therefore referenced by it's name instead of it's pid, this helps both, simplify the code and patterns of fault tollerance which will be discussed latterEach callback function have a set of possible return patterns that will guide the execution of the server processThe basic sucessfull responses are:{:ok, initial_state} from init/1{:reply, response, new_state} from handle_call/3{:noreply, new_state} from handle_cast/2 and handle_info/2Besides the sucessfull responses, are some others possible responses such ass {:stop, reason} and {:stop, reason, new_state}This kind of responses are used to gracefully terminate the server and provides information about itDont forget to check the docs to a complete overview of the possible responses patterns and its usesIt is important to keep track of where the code will be executed, on the client or in the server. Book page 176 has a nice diagram about it6.2.7 - OTP Compliant ProcessesIn production system you should avoid use the plain spawn/1 functionInstead all your processes should be OTP compliants, which means that they follow the OTP conventions so can be used in supervision trees and errors are handled with much more detailsAll processes powered by GenServer are automatically OTP compliantBesides GenServer elixir has much more modules that are OTP Compliant and can be used in many different use cases for example the modules Task and AgentSome others third-parties libraries implements OTP compliants abstractions tooMost of these abstractions are built on top of GenServer so properly understand of GenServer will help you to learn each one of these abstractions","ref":"chapter_6.html#6-2-using-genserver","title":"6 - Generic Server Process - 6.2 - Using GenServer","type":"extras"},{"doc":"7 - Building a Concurrent System","ref":"chapter_7.html","title":"7 - Building a Concurrent System","type":"extras"},{"doc":"Mix is a built in elixir tool that helps to manage a project in tasks such as:Create a new projectBuild production codeRun code locallyManage dependenciesRun testsAnd much moreThere are loads of mix commands that are very usefull to the project development, see the docsThe are no hard rules for files organization and names but a few guidelines:Use a commom top level alias such as Todo.List or Account.Server to avoid naming conflictsIn general it is one module per file, small helper modules used inside just one module could be place inside it as well. (Protocols too)File names are a snake_case version of the module's name implemented by it Todo.List -&gt; todo_listThe folder structure is corerespondent to the module names as well Todo.List -&gt; lib/todo/list.ex","ref":"chapter_7.html#7-1-working-with-mix","title":"7 - Building a Concurrent System - 7.1 - Working With mix","type":"extras"},{"doc":"Usually when a GenServer module are not named, and their numbers grow indefinitely with the system load, there is 2 options to work with this:Implement a kind of collection pure functional abstraction to work with multiple dataRun one data process for each needThe collection approach is not ideal because the abstraction still run under a single process, which would create a bottle neck since all clients will be addressing requests to this single process and because of the concurrent preemptive nature of BEAM the system throughput would be too lowThe multiple instance is the best choice because it fully takes advantage of the concurrent preemptive nature of BEAM, sharing the computational power between all the processesTo implement the multiple instance solution a new entity, something to keep track of all the instances running on the system and track them by something meaningfull to the domain. A key/value structure where the value is a pid and the key something that identifies the processes in that specific domain. eg: &lt;cpf&gt;: pid7.2.3 - Analyzing Process DependenciesSingleton processes are the first candidates of bottlenecks, because all the requests that use them can only be handled by the unique processes no paralization is possible and you will not be able to take advantage of all the CPU resourcesBeucause of this, singleton processes should not run slow operations, they must have a very high throughput otherwise it will be a huge bottleneck on the systemProcesses are internally sequential so singleton processes can be used as synchronization points on the system, because no matter how much messages are being send to it, it can only handle one at a timeThis feature is very important to the multiple instances processes too, because it guarantee that idependently of how many clients are trying to modify a specific instance, only one message will be handled at a time, totally eliminating race conditions.","ref":"chapter_7.html#7-2-managing-multiple-server-procesess","title":"7 - Building a Concurrent System - 7.2 - Managing Multiple Server Procesess","type":"extras"},{"doc":"Processes casts are less problematic than calls, casts from the caller pov does not affect nothing, but if the cast messages are being send faster than the server can handle the processes mailbox will grow indefinitelly impacting on future calls that will block the callers until timeout7.3.1 - Bypassing processThe bottleneck processes really need to be a process? Could it be a plain module and be executed on the caller process?Some flags that this processes REALLY NEED to exist:The code must manage a long-living stateThe code handle some kind of reusuable resource such as TCP connectionsThe code is a critical section of the code and must be synchronizedThe code can not be massivelly paralized for some reason such as disk operationsIf none of this conditions are matched, this process probally do not need to be a process at all7.3.2 - Handling Requests ConcurrentlyExampleUsually useful when requests depends on a commom state but can be handled in paralelIn this approach each new request to the process spawns a new process to handle itThe problem with this is that the concurrency is unbound, that means it can grow indefinetly which may impact the systemA typical solution for this problem is poolingWith pooling all the requests are still handled by a single process but it just forward them to a specific worker that will do the real workOn the singleton process creation you can define how much workers that singleton will manage","ref":"chapter_7.html#7-3-addressing-bottlenecks","title":"7 - Building a Concurrent System - 7.3 - Addressing Bottlenecks","type":"extras"},{"doc":"Processes are simple concurrent agents from the outside and fully sequential agents from the inside that can handle an internal stateYou can think about processes the same way you think about services in a microservices architectureThe processes are mostly independent but when they need to cooperate they do it using messages that are passed with calls or castsCalls are suitable for the most cases, but can affect the overall responsiveness because the caller is blocked until the server response is doneCasts can help a lot with overall responsiveness because after a call the caller is immediately free to handle another message, but the problem is the caller have any guarantee about the request sucess or fail it is a fire and forget operationCalls are sometimes used to apply backpressure on the callers, preventing them to spam the server with new messages which ultimately could lead to an out of memory situation where the VM would be terminatedCall x Cast is a situational choice that should always be analyzed carefully, in a rule of thumb always start with call and move to cast if responsiveness is affected","ref":"chapter_7.html#7-4-reasoning-with-processes","title":"7 - Building a Concurrent System - 7.4 - Reasoning With Processes","type":"extras"},{"doc":"8 - Fault Tolerance BasicsFault tolerance in the BEAM ecossytem is acknowledge the existence of failures, minimizing their impact and ultimately recover from them without human interactionSince it is impossible to predict everything that may go wrong, we assume that everything can fail, and no matter how important is a component that fail, it can not take down the entire systemBEAM powered systems are usually self-healing systems that can recover themselves from some kind of failuresThis property is again achieved by the concurrent nature of BEAM, since two processes are completly independent agents failures are never propagated except if the developer explicitly want it","ref":"chapter_8.html","title":"8 - Fault Tolerance Basics","type":"extras"},{"doc":"There are several ways that a runtime error can be raised, wrong aritmetics, call unknow functions and many othersWhen a runtime error happens the execution control is transfered to some kind of error-handling code, if it does not exist, the process that raised the error is terminatedErrors can be handled with try-catch constructs similar to other main stream languages8.1.1 - Error TypesThere is 3 types of errors in BEAMerrors: The classical error, used when a unexpected thing happenexits: A signal emited by processes that are terminatingthrows: Stop the execution flow throwing a value to be catched laterraise/1 is used to raise custom errorsThere are 2 approachs of working with a function that can failRaising an error: In this case the execution will fail and an error will be raisedMatching the result: Informing a failure with pattern matching of the function responseThe raising error approach is usefull when the code is really unexpected to fail, if all the system functionality relies on the existance of a file that is not there, you probally wants to raise an errorThe matching result is more usefull when the code eventually can fail and it is expectedexit/1 is used to terminating a process and inform the reasons to do sothrow/1 is used to change the execution flow somewhat similat to a goto expression8.1.2 - Handling ErrorsThe main way to intercept errors(error, exit or throw) is by try-catch constructsThe catch clause can use pattern matching to match errors, exactly like caseThe return valure of the try-catch expression is the value of the last executed statementThe clause after specifies a code that will always be executed, no matter what happensThe after result do not change the try-catch result value, and some syntax sugar is avaiable for it, see the docsTail-call optimization do not work with try catch operations as it's last expressionIn comparison to main stream languages the try-catch is way less used in elixirUsually elixir systems let the process crash and them handle it later, starting the process again for instanceThis works perfectly with bugs that happens randonly and are hard to reproduce, because they occur due to hardware failures and stuffs like that","ref":"chapter_8.html#8-1-runtime-errors","title":"8 - Fault Tolerance Basics - 8.1 - Runtime Errors","type":"extras"},{"doc":"Although the processes are completly isolated, sometimes it's necessary to create somekind of link between themIt may be because of a processes heavily relies on another process service or would be counter productive continuouly running the processes without the others8.2.1 - Linking ProcessesLink is a concept that two processes that are linked when one of them terminated the other one will receive an exit signal containing some information about the terminated process and reasons of the crash and if the exit signal is not :normal the recipient process will be terminated as wellInstead of just terminate, recipient processes can trap exits signal and handling them in some way. This can be done with Process.flag(:trap_exit, true)This makes all the exit signals to be received as mesages in the process mailbox that has a spcific pattern that could be matched on the receive macroAll links are bidirectional, this means that both processes will send messages to each other in case of failures8.2.2 - MonitorsMonitors are kind of unidirectional links, one process is notified about the others failures but not the other way aroundTo monitor a process use Process.monitor(target_pid)When a monitored process dies, the monitor will receive a message on it's mailboxThere are 2 main differences between monitors and linksLinks are bidirectional always while monitor are unidirectionalLinks (without traps) will always terminate both processes while on monitor it's just a message, which can be handled or ignored","ref":"chapter_8.html#8-2-concurrent-system-s-errors","title":"8 - Fault Tolerance Basics - 8.2 - Concurrent System's Errors","type":"extras"},{"doc":"With links, exit traps and monitors, a process can detect errors in a concurrent system and act upon it based on the information that is passed to it on the error messagesA processes that is responsible for just doing it is called a SupervisorSupervisors are generic processes that manages the lifecycle of other processes in a concurrent systemIt can start new processes, these processes there fore are called children of it's supervisorThe supervisor is responsible for all its children, and receive the exit messages act upon them in a proper wayProcess that are not supervisors are called workersIf a worker dies due to a bug, this part of the system will be gone foreverSupervisors can be useful to restart these workers in this caseThe Supervisor module is used to create supervisorsA supervisor works like this: 1 - Traps exits 2 - Starts all the children 3 - At any given point in time that a child terminate, handle its exit message and perform corrective actions 4 - If a supervisor terminates, all its children are terminated as wellThere are two main ways to start a supervisor:Passing a list: Invoke Supervisor.start_link/2 providing a list with modules to be initialized as its children together with some aditional optionsCallback module: Implement a callback module, similar to GenServer approach, that return all these information about children and optionsA different start function must be used: GenServer.start_link/3 this function must be used when you want to create a link between caller and server on the server start executionOptions given to supervisor will dictate several aspects of the supervisor behaviour, for instance the option :strategy defines how children exits will be handledRegistered processes names are important to supervisors because they provide a reliable way to finding a process and communicate to itUsually supervisors are wrapped inside a moduledefmodule Todo.System do def start_link do Supervisor.start_link( [Todo.Cache], strategy: :one_for_one ) end end Although this simple approach of passing the children list to the Supervisor.start_link/2 works, sometimes you need a bit more of control about what happens before and after the creation of the supervisor, for it you can build the supervisor module a bit differentSupervisors do not try to restart children indefinetely, if a process crashes too much in predetermined period of time, the supervisor will give up and terminate it selfThe boundaries limits of this restart task can be customized inside de supervisorThis restart frequency feature is helpful on how supervision trees works8.3.1 - Child SpecificationIn order to know how to work with each child the supervisor must know 3 things:How should child be initializedWhat should be dont if the child terminatesHow to uniquely distinguish each childAll these information is the child specification. eg: %{ id: arbitray_term_that_unique_idenfiy, start: {module, :start_function_name, [start_function_args]} } To avoid passing child specification hard coded, a default function call is implemented by GenServer and used by Supervisor this function is child_spec/1 that return the correct child specification for the module, and can be override in case you need more control about it","ref":"chapter_8.html#8-3-supervisors","title":"8 - Fault Tolerance Basics - 8.3 - Supervisors","type":"extras"},{"doc":"9 - Isolating Error Effects","ref":"chapter_9.html","title":"9 - Isolating Error Effects","type":"extras"},{"doc":"9.1.1 - Loosely Dependent PartsStarting workers processes within other workers can lead to a coarse-grained error recovery, because exit signals will be send to all linked processesThe usual approach is to have all independent or loosely dependent processes directly linked to supervisorsAll childs initialization is synchronously, and in order as specified. If a child process need more complex initialization, use the self message trick9.1.2 - Rich Process DiscoverySince processes can be restarted by supervisors, the system can not relie on processes pids. Because a certain process can be restarted and has a different pid nowTo solve this problem we need a mechanism that allow processes to be registered with a symbolic name, which could be an arbitrary term instead of just atoms that registered namesSuch mechanism would make possible every time a process is restarted, it be registered under the same name, and all reference to it would be via this symbolic name instead of pidThis mechanism in elixir is the Registry module, which works as an key/value pair between arbitrary terms and pidsInternally Registry is powered by ETS which make it much more powerfull than a simple mapA process can register it self to a Registry using the function Registry.register/3Registered processes can be discovered using the function Registry.lookup/2One usefull property of registries is that it links to all registered processes, so it can automatically remove a process from the register when the process terminate9.1.3 - Via TuplesExampleUntil now, the only way you have to identify processes was pid, which is the raw process address on BEAMAn alternative to pids are via tuples, they identifie a process not with raw pid, but providing a way of discover itA via tuple format is something like this {:via, some_module, some_arg}, and it provides information about how to discover the process pid, because at the end of the day, the pid is what you want:via atom just informs that the via tuple method is being usedsome_module holds the module by how the discover will happen, this module that has all the behaviour &quot;knowledge&quot;, which is a set of well defined functionssome_arg holds the data that will be passed to some_module's well defined functions that enable it to find the pidUsing via tuples processes can be registered under arbitrary complex terms as keys9.1.4 - Regisitry Processdefmodule Account.ProcessRegistry do def start_link() do Registry.start_link(name: __MODULE__, keys: :unique) end def via_tuple(key) do {:via, Registry, {__MODULE__, key}} end def child_spec(_) do Supervisor.child_spec( Registry, id: __MODULE__, start: {__MODULE__, :start_link, []} ) end end Registries are processes as well, so they must be supervisioned, that is why you need the clid_spec(_) functionThe via_tuple/1 function will be used by any process that wants to register it self under this registryAn usual approach to define processes keys under a registry is using a tuple like this {module_name, id}, this reduce the chance of a name conflict between 2 processesThe via_tuple/1 function is also used when a process need to discover the pid9.1.5 - Supervising SupervisorsDue to restart frequency, its not ideal to a supervisor handle too many childrenTherefore is a usual approach to split children between other supervisors that will be supervised by another supervisorSupervisors treats other supervisors different than workers, it means that they have different specificationsThis concept of supervised supervisors is what origins the supervision tree9.1.6 - Organizing Supervision TreeAlthough supervision tree play an important role on fault-tolerance topic, it most important role is to provide a proper start order for the systemIf processes are kind of services, supervisors are service managers, kind of a built in systemdBy holding the knowlodge of how system should be started, supervisors provide a way to stop/restart specific parts of the system without have to worry about side effects, because all children will be taken down and restarted correctlyThis allows to reasoning about errors on the system much easierAll processes that are started under a supervisor must be OTP compliantPlain spawn_link processes should not be handled by supervisors directly, although it can be used on workersAnother important feature is the ability to shutdown the system (or parts of it) without leave dangling processes behindWorkers that traps exits have a chance to perform some action before being terminated by the supervisor in a system terminate scenarioSupervisors can be informed of how treat workers termination individually, if it waits, for how long, etcWorkers can inform the supervisor how to treat their faliures:Restart the process is the default one:temporary workers are not restarted when terminated:transient workers are restarted only if it terminates abnormallySupervisors can have different restart strategies:one_for_one restart only the crashed process:one_for_all restart all children:rest_for_one restart only younger siblings of the crashed worker, as specified on initialization","ref":"chapter_9.html#9-1-supervision-trees","title":"9 - Isolating Error Effects - 9.1 - Supervision Trees","type":"extras"},{"doc":"In some cases, the default implementation of providing before hand all the children to supervisor are not what you needWhen children can come and go by demand a DynamicSupervisor is neededChildren can be added dynamically using the DynamicSupervisor.start_child/2 functionAll initialization is synchronously","ref":"chapter_9.html#9-2-dynamic-supervisors","title":"9 - Isolating Error Effects - 9.2 - Dynamic Supervisors","type":"extras"},{"doc":"The supervision tree concept allows a very elegant and eficient way to handle unexpected errorsBecause of it the code is way clearer, without any defensive constructs noiseThis style of programming is described by Joe Armstrong in his PhD thesisWhen a process crash it is restarted with a clean state, some requests will fail, but the entire system functionality will be back to normal soon, because all the things are starting freshAlthough &quot;Let it crash&quot; is different from &quot;Let everything crash&quot;, some processes and errors must be handled explicitlyCritical processesErros that can be meaningful handled9.3.1 - Critial ProcessesCritical processes, informally called error-kernel processes are:Processes the entire system relies onProcesses which the state can not be restored in a simple and consistent wayThis kind of code must be as simple as possible, a usual pattern to simplify error-kernel processes is to split it into two processes, one handle the logic and other handle the state, this way the logic one can be easily restarted because it has no state and the state one is hard to crash because it just handle stateTry catch mechanism can be used in every message handler function, and if something goes wrong, just keep the previous state9.3.2 - Meaningful ErrorsThe point of supervisors is to handle unexpected errorsIn general, if you know what to do with an error you must handle itFor instance, an access denied error on an archive must be treated asking for the users password9.3.3 - Preserving StateBy default, state is not preserved on process crash, so you have to implement it if you need itThe usual approach is to have the state being saved outside the process, a database or another process for instance, and restore this state when the process restart, the previous state is restoredBe careful when preserving state, if a corrupted state is preserved, the process will be crash rapidly everytime it is restarted, ultimately taking down his supervisorAs a rule, the state should be persisted just after all transformation is done, and consistency is guaranteeIdeally, restart clean always it is possible","ref":"chapter_9.html#9-3-let-it-crash","title":"9 - Isolating Error Effects - 9.3 - Let It Crash","type":"extras"},{"doc":"10 - Beyond Genserver","ref":"chapter_10.html","title":"10 - Beyond Genserver","type":"extras"},{"doc":"Tasks are used when you need a one off job. A job that executes and terminate it self when done.In this sense Task and GenServer has 2 different workflows. Tasks does not serve any requests, just execute his job and it's doneTask can be interpreted as a concurrent function call10.1.1 - Awaited Taskslong_job = fn -&gt; Process.sleep(2000) :some_result end async_task = Task.async(long_job) # No sleep at all is executed. All computation is done by another process # Waits for the async_task response result = Task.await(async_task) Awaited tasks send the result value back to the caller when the computation is done Very similar to javascript's async await pattern10.1.2 - Non Awaited Tasksdefmodule SupervisedTask do use Task def start_link(_arg) do Task.start_link(&amp;do_something/1) end endNon awaited taks does not return any value back to the caller, instead it just terminate with :normal reasonThe main use case of non awaited tasks are to start async jobs under a supervisor, and be able to restart them if anything goes wrong","ref":"chapter_10.html#10-1-tasks","title":"10 - Beyond Genserver - 10.1 - Tasks","type":"extras"},{"doc":"defmodule AgentPoweredServer do def start_link(_) do Agent.start_link(fn -&gt; ) endAgent are a simple version of GenServer, they require less boilerplate and are more straightforwardAgent is kind of a GenServer that can be manipulated via lambda functionsAgents holds a state that can only be manipulated via injected functionsBecause of it, it is a best practice always wrap an agent code inside a moduleThe down side is that Agent does not support as many use cases as GenServer, agents can not handle plain messagesAs a rule of thumb, if you dont need handle_info or terminate on your GenServer, it probally can be replaced by an Agent","ref":"chapter_10.html#10-2-agents","title":"10 - Beyond Genserver - 10.2 - Agents","type":"extras"},{"doc":"Example)It is a mechanism that allows share data between multiple processes more efficientlyUsed as an optimization tool, nothing can be done with ETS that can not be done with GenServerTypical scenario to use an ETS table is shared key/value structures and counters. The usage of other mechanism to solve this problem would probally lead to scalability issues (See: GenServer Implementation vs ETS Implementation)The main difference is that on the GenServer implementation, requests to the data structure are limited by the process execution time, while on the ETS version, all the requests have access directly to the data itself.ETS features:MutableWrites and Reads are concurrentLast write winsAny data, in or out, is deep copiedNo pressure on garbage collector, deleted data, is automatic releasedLinked to its owner processOther than owner process termination, there is no way to release ETS memoryRead data with patterns","ref":"chapter_10.html#10-3-ets-tables","title":"10 - Beyond Genserver - 10.3 - ETS Tables","type":"extras"},{"doc":"11- Working With Components","ref":"chapter_11.html","title":"11- Working With Components","type":"extras"},{"doc":"It is a way to keep together multiple modules and resources as a unique executable systemIt is defined by the application resource file, writen in pure erlangMix tool provides shortcuts to define it inside mix.exs fileOTP application are not equivalente to Mix projects, the former is a runtime construct and the later a compile-time construct, the OTP application is derived from the Mix projectThe callback module is the main module that starts the applicationLibrary applications do not have a callback module","ref":"chapter_11.html#11-1-otp-applications","title":"11- Working With Components - 11.1 - OTP Applications","type":"extras"},{"doc":"Dependencies must be specified in mix.exs fileDependencies are specified as tuples like: {:dependency_name, &quot;version requiriments&quot;}Version synstax can be found on hexdocs documentationAfter specified you must run mix deps.get to acquire the dependencies from a remote repositoryThis command will generate the mix.lock file which contains the references to each dependencymix.lock file is used by the mix compile command","ref":"chapter_11.html#11-2-dependencies","title":"11- Working With Components - 11.2 - Dependencies","type":"extras"},{"doc":"Web servers can be implemented from scratch but it is pointless. Instead you coul use some battle tested libraries such ass cowboy and plug. Or even a really powerfull framework like phoenixThe integration of the HTTP server wit the system is flawless. The &quot;Phoenix is not your application&quot; approach correlates strongly with the best architecturals practices of the modern software development","ref":"chapter_11.html#11-3-web-server","title":"11- Working With Components - 11.3 - Web Server","type":"extras"},{"doc":"Application envioronment is a key/value struct that holds data that is accessible from any moduleThe definition of this struct is done by the config.exs file, usually locate inside the config folderInside it you can write elixir code to define the variablesThe configuration can vary accordingly to the environment, by default: prod, dev and testConfig scripts are evaluated before the compilation, so you cant use any custom module","ref":"chapter_11.html#11-4-configuration","title":"11- Working With Components - 11.4 - Configuration","type":"extras"}]